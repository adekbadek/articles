<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/es6-strings-and-unicode-in-depth">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/es6-strings-and-unicode-in-depth"><div><img src="https://i.imgur.com/0hBAHi4.jpg" alt="ES6 Strings (and Unicode, &#x2764;) in Depth"></div></a>

<h1>ES6 Strings (and Unicode, &#x2764;) in Depth</h1>

<p><kbd>es6</kbd> <kbd>string</kbd> <kbd>unicode</kbd> <kbd>es6-in-depth</kbd></p>

<blockquote><p>Yo. Here&#x2019;s another edition of <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;I can&#x2019;t believe they killed off Stringer Bell&#x201D;</em> &#x2013; in Depth</a> series. If you&#x2019;ve never &#x2026;</p></blockquote>

<div><p>Yo. Here&#x2019;s another edition of <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 &#x2013; <em>&#x201C;I can&#x2019;t believe they killed off Stringer Bell&#x201D;</em> &#x2013; in Depth</a> series. If you&#x2019;ve never been around here before, start with <a href="https://ponyfoo.com/articles/a-brief-history-of-es6-tooling">A Brief History of ES6 Tooling</a>. Then, make your way through <a href="https://ponyfoo.com/articles/es6-destructuring-in-depth">destructuring</a>, <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth">template literals</a>, <a href="https://ponyfoo.com/articles/es6-arrow-functions-in-depth">arrow functions</a>, the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth">spread operator and rest parameters</a>, improvements coming to <a href="https://ponyfoo.com/articles/es6-object-literal-features-in-depth">object literals</a>, the new <a href="https://ponyfoo.com/articles/es6-classes-in-depth"><em>classes</em></a> sugar on top of prototypes, <a href="https://ponyfoo.com/articles/es6-let-const-and-temporal-dead-zone-in-depth"><code class="md-code md-code-inline">let</code>, <code class="md-code md-code-inline">const</code>, and the <em>&#x201C;Temporal Dead Zone&#x201D;</em></a>, <a href="https://ponyfoo.com/articles/es6-iterators-in-depth">iterators</a>, <a href="https://ponyfoo.com/articles/es6-generators-in-depth">generators</a>, <a href="https://ponyfoo.com/articles/es6-symbols-in-depth">Symbols</a>, <a href="https://ponyfoo.com/articles/es6-maps-in-depth">Maps</a>, <a href="https://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth">WeakMaps, Sets, and WeakSets</a>, <a href="https://ponyfoo.com/articles/es6-proxies-in-depth">proxies</a>, <a href="https://ponyfoo.com/articles/es6-proxy-traps-in-depth">proxy traps</a>, <a href="https://ponyfoo.com/articles/more-es6-proxy-traps-in-depth">more proxy traps</a>, <a href="https://ponyfoo.com/articles/es6-reflection-in-depth">reflection</a>, <a href="https://ponyfoo.com/articles/es6-number-improvements-in-depth"><code class="md-code md-code-inline">Number</code></a>, <a href="https://ponyfoo.com/articles/es6-math-additions-in-depth"><code class="md-code md-code-inline">Math</code></a>, <a href="https://ponyfoo.com/articles/es6-array-extensions-in-depth"><code class="md-code md-code-inline">Array</code></a>, and <a href="https://ponyfoo.com/articles/es6-object-changes-in-depth"><code class="md-code md-code-inline">Object</code></a>. Today we&#x2019;ll be serving updates to the <code class="md-code md-code-inline">String</code> object coming in ES6.</p></div>

<blockquote></blockquote>

<div><blockquote> <p>Like I did in previous articles on the series, I would love to point out that you should probably <a href="https://ponyfoo.com/articles/universal-react-babel#setting-up-babel">set up Babel</a> and follow along the examples with either a REPL or the <code class="md-code md-code-inline">babel-node</code> CLI and a file. That&#x2019;ll make it so much easier for you to <strong>internalize the concepts</strong> discussed in the series. If you aren&#x2019;t the <em>&#x201C;install things on my computer&#x201D;</em> kind of human, you might prefer to hop on <a href="http://codepen.io/" target="_blank" rel="noopener noreferrer">CodePen</a> and then click on the gear icon for JavaScript &#x2013; <em>they have a Babel preprocessor which makes trying out ES6 a breeze.</em> Another alternative that&#x2019;s also quite useful is to use Babel&#x2019;s <a href="http://babeljs.io/repl/" target="_blank" rel="noopener noreferrer">online REPL</a> <em>&#x2013; it&#x2019;ll show you compiled ES5 code to the right of your ES6 code for quick comparison.</em></p> </blockquote> <p>Before getting into it, let me <a href="https://www.patreon.com/bevacqua" target="_blank" rel="noopener noreferrer"><em>shamelessly ask for your support</em></a> if you&#x2019;re enjoying my <a href="https://ponyfoo.com/articles/tagged/es6-in-depth">ES6 in Depth</a> series. Your contributions will go towards helping me keep up with the schedule, server bills, keeping me fed, and maintaining <strong>Pony Foo</strong> as a veritable source of JavaScript goodies.</p> <p>Thanks for reading that, and let&#x2019;s go into updates to the <code class="md-code md-code-inline">String</code> object.</p></div>

<div><h1 id="updates-to-string">Updates to <code class="md-code md-code-inline">String</code></h1> <p>We&#x2019;ve already covered <a href="https://ponyfoo.com/articles/es6-template-strings-in-depth" aria-label="ES6 Template Literals in Depth on Pony Foo">template literals</a> earlier in the series, and you may recall that those can be used to mix strings and variables to produce string output.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">greet</span> <span class="md-code-params">(name)</span> </span>{
  <span class="md-code-keyword">return</span> `hello ${name}!`
}
greet(<span class="md-code-string">&apos;ponyfoo&apos;</span>)
<span class="md-code-comment">// &lt;- &apos;hello ponyfoo!&apos;</span>
</code></pre> <p>Besides template literals, strings are getting a numbre of new methods come ES6. These can be categorized as string manipulation methods and unicode related methods.</p> <ul> <li>String Manipulation <ul> <li><a href="#stringprototypestartswith"><code class="md-code md-code-inline">String.prototype.startsWith</code></a></li> <li><a href="#stringprototypeendswith"><code class="md-code md-code-inline">String.prototype.endsWith</code></a></li> <li><a href="#stringprototypeincludes"><code class="md-code md-code-inline">String.prototype.includes</code></a></li> <li><a href="#stringprototyperepeat"><code class="md-code md-code-inline">String.prototype.repeat</code></a></li> <li><a href="#stringprototype-symboliterator"><code class="md-code md-code-inline">String.prototype[Symbol.iterator]</code></a></li> </ul> </li> <li><a href="#unicode">Unicode</a> <ul> <li><a href="#stringprototypecodepointat"><code class="md-code md-code-inline">String.prototype.codePointAt</code></a></li> <li><a href="#stringfromcodepoint%60"><code class="md-code md-code-inline">String.fromCodePoint</code></a></li> <li><a href="#stringprototypenormalize"><code class="md-code md-code-inline">String.prototype.normalize</code></a></li> </ul> </li> </ul> <p>We&#x2019;ll begin with the string manipulation methods and then we&#x2019;ll take a look at the unicode related ones.</p> <h1 id="stringprototypestartswith"><code class="md-code md-code-inline">String.prototype.startsWith</code></h1> <p>A very common question in our code is <em>&#x201C;does this string start with this other string?&#x201D;</em>. In ES5 we&#x2019;d ask that question using the <code class="md-code md-code-inline">.indexOf</code> method.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ponyfoo&apos;</span>.indexOf(<span class="md-code-string">&apos;foo&apos;</span>)
<span class="md-code-comment">// &lt;- 4</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span>.indexOf(<span class="md-code-string">&apos;pony&apos;</span>)
<span class="md-code-comment">// &lt;- 0</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span>.indexOf(<span class="md-code-string">&apos;horse&apos;</span>)
<span class="md-code-comment">// &lt;- -1</span>
</code></pre> <p>If you wanted to check if a string started with another one, you&#x2019;d compare them with <code class="md-code md-code-inline">.indexOf</code> and check whether the <em>&#x201C;needle&#x201D;</em> starts at the <code class="md-code md-code-inline">0</code> position &#x2013; the beginning of the string.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ponyfoo&apos;</span>.indexOf(<span class="md-code-string">&apos;pony&apos;</span>) <mark class="md-mark md-code-mark">=== <span class="md-code-number">0</span></mark>
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span>.indexOf(<span class="md-code-string">&apos;foo&apos;</span>) === <span class="md-code-number">0</span>
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span>.indexOf(<span class="md-code-string">&apos;horse&apos;</span>) === <span class="md-code-number">0</span>
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>You can now use the more descriptive and terse <code class="md-code md-code-inline">.startsWith</code> method instead.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ponyfoo&apos;</span><mark class="md-mark md-code-mark">.startsWith</mark>(<span class="md-code-string">&apos;pony&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span><mark class="md-mark md-code-mark">.startsWith</mark>(<span class="md-code-string">&apos;foo&apos;</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span><mark class="md-mark md-code-mark">.startsWith</mark>(<span class="md-code-string">&apos;horse&apos;</span>)
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>If you wanted to figure out whether a string contains another one starting in a specific location, it would get quite verbose, as you&#x2019;d need to grab a slice of that string first.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ponyfoo&apos;</span><mark class="md-mark md-code-mark">.slice(<span class="md-code-number">4</span>)</mark>.indexOf(<span class="md-code-string">&apos;foo&apos;</span>) === <span class="md-code-number">0</span>
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>The reason why you can&#x2019;t just ask <code class="md-code md-code-inline">=== 4</code> is that this would give you false negatives when the query is found before reaching that index.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;foo,<mark class="md-mark md-code-mark">foo</mark>&apos;</span>.indexOf(<span class="md-code-string">&apos;foo&apos;</span>) === <span class="md-code-number">4</span>
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">false</mark>, because result was <mark class="md-mark md-code-mark">0</mark></span>
</code></pre> <p>Of course, you could use the <code class="md-code md-code-inline">startIndex</code> parameter for <code class="md-code md-code-inline">indexOf</code> to get around that. Note that we&#x2019;re still comparing against <code class="md-code md-code-inline">4</code> in this case, because the string wasn&#x2019;t split into smaller parts.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;foo,foo&apos;</span>.indexOf(<span class="md-code-string">&apos;foo&apos;</span>, <mark class="md-mark md-code-mark">4</mark>) === <mark class="md-mark md-code-mark">4</mark>
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Instead of keeping all of these string searching implementation details in your head and writing code that worries too much about the how and not so much about the what, you could just use <code class="md-code md-code-inline">startsWith</code> passing in the optional <code class="md-code md-code-inline">startIndex</code> parameter as well.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;foo,foo&apos;</span><mark class="md-mark md-code-mark">.startsWith</mark>(<span class="md-code-string">&apos;foo&apos;</span>, <mark class="md-mark md-code-mark">4</mark>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Then again, it&#x2019;s kind of confusing that the method is called <code class="md-code md-code-inline">.startsWith</code> but we&#x2019;re starting at a non-zero index &#x2013; that being said it sure beats using <code class="md-code md-code-inline">.indexOf</code> when we actually want a boolean result.</p> <h1 id="stringprototypeendswith"><code class="md-code md-code-inline">String.prototype.endsWith</code></h1> <p>This method mirrors <code class="md-code md-code-inline">.startsWith</code> in the same way that <code class="md-code md-code-inline">.lastIndexOf</code> mirrors <code class="md-code md-code-inline">.indexOf</code>. It tells us whether a string ends with another string.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ponyfoo&apos;</span>.endsWith(<span class="md-code-string">&apos;foo&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span>.endsWith(<span class="md-code-string">&apos;pony&apos;</span>)
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>Just like <code class="md-code md-code-inline">.startsWith</code>, we have a position index that indicates where the lookup should end. It defaults to the length of the string.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ponyfoo&apos;</span>.endsWith(<span class="md-code-string">&apos;foo&apos;</span>, <span class="md-code-number">7</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span>.endsWith(<span class="md-code-string">&apos;pony&apos;</span>, <span class="md-code-number">0</span>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span>.endsWith(<span class="md-code-string">&apos;pony&apos;</span>, <span class="md-code-number">4</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Yet another method that simplifies a specific use case for <code class="md-code md-code-inline">.indexOf</code> is <code class="md-code md-code-inline">.includes</code>.</p> <h1 id="stringprototypeincludes"><code class="md-code md-code-inline">String.prototype.includes</code></h1> <p>You can use <code class="md-code md-code-inline">.includes</code> to figure out whether a string contains another one.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ponyfoo&apos;</span><mark class="md-mark md-code-mark">.includes</mark>(<span class="md-code-string">&apos;ny&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span>.includes(<span class="md-code-string">&apos;sf&apos;</span>)
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>This is equivalent to the ES5 use case of <code class="md-code md-code-inline">.indexOf</code> where we&#x2019;d compare its results with <code class="md-code md-code-inline">-1</code> to see if the search string was anywhere to be found.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ponyfoo&apos;</span><mark class="md-mark md-code-mark">.indexOf</mark>(<span class="md-code-string">&apos;ny&apos;</span>) <mark class="md-mark md-code-mark">!== -<span class="md-code-number">1</span></mark>
<span class="md-code-comment">// &lt;- true</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span><mark class="md-mark md-code-mark">.indexOf</mark>(<span class="md-code-string">&apos;sf&apos;</span>) <mark class="md-mark md-code-mark">!== -<span class="md-code-number">1</span></mark>
<span class="md-code-comment">// &lt;- false</span>
</code></pre> <p>Naturally you can also pass in a start index where the search should begin.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ponyfoo&apos;</span>.includes(<span class="md-code-string">&apos;ny&apos;</span>, <mark class="md-mark md-code-mark">3</mark>)
<span class="md-code-comment">// &lt;- false</span>
<span class="md-code-string">&apos;ponyfoo&apos;</span>.includes(<span class="md-code-string">&apos;ny&apos;</span>, <mark class="md-mark md-code-mark">2</mark>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre> <p>Let&#x2019;s move onto something that&#x2019;s not an <code class="md-code md-code-inline">.indexOf</code> replacement.</p> <h1 id="stringprototyperepeat"><code class="md-code md-code-inline">String.prototype.repeat</code></h1> <p>This handy method allows you to repeat a string <code class="md-code md-code-inline">count</code> times.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;na&apos;</span><mark class="md-mark md-code-mark">.repeat</mark>(<span class="md-code-number">0</span>)
<span class="md-code-comment">// &lt;- &apos;&apos;</span>
<span class="md-code-string">&apos;na&apos;</span>.repeat(<span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- &apos;na&apos;</span>
<span class="md-code-string">&apos;na&apos;</span>.repeat(<span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- &apos;na<mark class="md-mark md-code-mark">na</mark>&apos;</span>
<span class="md-code-string">&apos;na&apos;</span>.repeat(<span class="md-code-number">5</span>)
<span class="md-code-comment">// &lt;- &apos;na<mark class="md-mark md-code-mark">nananana</mark>&apos;</span>
</code></pre> <p>The provided <code class="md-code md-code-inline">count</code> should be a positive finite number.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;na&apos;</span>.repeat(<span class="md-code-literal">Infinity</span>)
<span class="md-code-comment">// &lt;- RangeError</span>
<span class="md-code-string">&apos;na&apos;</span>.repeat(-<span class="md-code-number">1</span>)
<span class="md-code-comment">// &lt;- RangeError</span>
</code></pre> <p>Non-numeric values are coerced into numbers.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;na&apos;</span>.repeat(<span class="md-code-string">&apos;na&apos;</span>)
<span class="md-code-comment">// &lt;- &apos;&apos;</span>
<span class="md-code-string">&apos;na&apos;</span>.repeat(<span class="md-code-string">&apos;3&apos;</span>)
<span class="md-code-comment">// &lt;- &apos;nanana&apos;</span>
</code></pre> <p>Using <code class="md-code md-code-inline">NaN</code> is as good as <code class="md-code md-code-inline">0</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;na&apos;</span>.repeat(<span class="md-code-literal">NaN</span>)
<span class="md-code-comment">// &lt;- &apos;&apos;</span>
</code></pre> <p>Decimal values are floored.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;na&apos;</span>.repeat(<span class="md-code-number">3.9</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">&apos;nanana&apos;</mark>, count was floored to 3</span>
</code></pre> <p>Values in the <code class="md-code md-code-inline">(-1, 0)</code> range are rounded to <code class="md-code md-code-inline">-0</code> becase <code class="md-code md-code-inline">count</code> is passed through <a href="http://ecma-international.org/ecma-262/6.0/#sec-tointeger" target="_blank" rel="noopener noreferrer" aria-label="7.1.4 ToInteger in ECMAScript 6 Specification"><code class="md-code md-code-inline">ToInteger</code></a>, as documented by <a href="http://ecma-international.org/ecma-262/6.0/#sec-string.prototype.repeat" target="_blank" rel="noopener noreferrer" aria-label="21.1.3.13 String.prototype.repeat in ECMAScript 6 Specification">the specification</a>. That step in the specification dictates that <code class="md-code md-code-inline">count</code> be casted with a formula like the one below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">ToInteger</span> <span class="md-code-params">(number)</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Math</span>.floor(<span class="md-code-built_in">Math</span>.abs(number)) * <span class="md-code-built_in">Math</span>.sign(number)
}
</code></pre> <p>The above translates to <code class="md-code md-code-inline">-0</code> for any values in the <code class="md-code md-code-inline">(-1, 0)</code> range. Numbers below that will throw, and numbers above that won&#x2019;t behave surprisingly, as you can only take <code class="md-code md-code-inline">Math.floor</code> into account for positive values.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;na&apos;</span>.repeat(-<span class="md-code-number">0.1</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">&apos;&apos;</mark>, count was rounded to <mark class="md-mark md-code-mark">-0</mark></span>
</code></pre> <p>A good example use case for <code class="md-code md-code-inline">.repeat</code> may be your typical <em>&#x201C;padding&#x201D;</em> method. The method shown below takes a multiline string and pads every line with as many <code class="md-code md-code-inline">spaces</code> as desired.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">pad</span> <span class="md-code-params">(text, spaces)</span> </span>{
  <span class="md-code-keyword">return</span> text.split(<span class="md-code-string">&apos;\n&apos;</span>).map(line =&gt; <span class="md-code-string">&apos; &apos;</span><mark class="md-mark md-code-mark">.repeat(spaces)</mark> + line).join(<span class="md-code-string">&apos;\n&apos;</span>)
}
pad(<span class="md-code-string">&apos;a\nb\nc&apos;</span>, <span class="md-code-number">2</span>)
<span class="md-code-comment">// &lt;- &apos;  a\n  b\n  c&apos;</span>
</code></pre> <p>In ES6, strings adhere to the <a href="https://ponyfoo.com/articles/es6-iterators-in-depth" aria-label="ES6 Iterators in Depth on Pony Foo">iterable protocol</a>.</p> <h1 id="stringprototype-symboliterator"><code class="md-code md-code-inline">String.prototype[Symbol.iterator]</code></h1> <p>Before ES6, you could access each <strong>code unit</strong> <em>(we&#x2019;ll define these in a second)</em> in a string via indices &#x2013; kind of like with arrays. That meant you could loop over <strong>code units</strong> in a string with a <code class="md-code md-code-inline">for</code> loop.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = <span class="md-code-string">&apos;foo&apos;</span>
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>; i &lt; text.length; i++) {
  <span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">text[i]</mark>)
  <span class="md-code-comment">// &lt;- &apos;f&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;o&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;o&apos;</span>
}
</code></pre> <p>In ES6, you could loop over the <strong>code points</strong> <em>(not the same as <strong>code units</strong>)</em> of a string using a <code class="md-code md-code-inline">for..of</code> loop, because strings are <em>iterable</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> <mark class="md-mark md-code-mark">codePoint</mark> of <span class="md-code-string">&apos;foo&apos;</span>) {
  <span class="md-code-built_in">console</span>.log(codePoint)
  <span class="md-code-comment">// &lt;- &apos;f&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;o&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;o&apos;</span>
}
</code></pre> <p>What is this <code class="md-code md-code-inline">codePoint</code> variable? There is <em>a not-so-subtle distinction</em> between <strong>code units</strong> and <strong>code points</strong>. Let&#x2019;s switch protocols and talk about <em>Unicode</em>.</p> <h1 id="unicode">Unicode</h1> <p>JavaScript strings are represented using <a href="http://unicodebook.readthedocs.io/unicode_encodings.html#ucs-2-ucs-4-utf-16-and-utf-32" target="_blank" rel="noopener noreferrer" aria-label="UCS-2, UCS-4, UTF-16 and UTF-32"><em>UTF-16 code units</em></a>. Each code unit can be used to represent a code point in the <code class="md-code md-code-inline">[U+0000, U+FFFF]</code> range &#x2013; also known as the <em>&#x201C;basic multilingual plane&#x201D;</em> (BMP). You can represent individual code points in the BMP plane using the <code class="md-code md-code-inline">&apos;\u3456&apos;</code> syntax. You could also represent code units in the <code class="md-code md-code-inline">[U+0000, U+0255]</code> using the <code class="md-code md-code-inline">\x00..\xff</code> notation. For instance, <code class="md-code md-code-inline">&apos;\xbb&apos;</code> represents <code class="md-code md-code-inline">&apos;&#xBB;&apos;</code>, the <code class="md-code md-code-inline">187</code> character, as you can verify by doing <code class="md-code md-code-inline">parseInt(&apos;bb&apos;, 16)</code> &#x2013; or <code class="md-code md-code-inline">String.fromCharCode(187)</code>.</p> <p>For code points beyond <code class="md-code md-code-inline">U+FFFF</code>, you&#x2019;d represent them as a surrogate pair. That is to say, two contiguous code units. For instance, the horse emoji <code class="md-code md-code-inline">&apos;&#x1F40E;&apos;</code> code point is represented with the <code class="md-code md-code-inline">&apos;\ud83d\udc0e&apos;</code> contiguous code units. In ES6 notation you can also represent code points using the <code class="md-code md-code-inline">&apos;\u{1f40e}&apos;</code> notation <em>(that example is also the horse emoji)</em>. Note that the internal representation hasn&#x2019;t changed, so there&#x2019;s <strong>still two code units</strong> behind that code point. In fact, <code class="md-code md-code-inline">&apos;\u{1f40e}&apos;.length</code> evaluates to <code class="md-code md-code-inline">2</code>.</p> <p>The <code class="md-code md-code-inline">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</code> string found below evaluates to a few emoji.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span>
<span class="md-code-comment">// &lt;- &apos;&#x1F40E;&#x1F471;&#x2764;&apos;</span>
</code></pre>
<p>While that string consists of 5 code units, we know that the length should really be three &#x2013; as there&#x2019;s only three emoji.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span>.length
<span class="md-code-comment">// &lt;- 5</span>
<span class="md-code-string">&apos;&#x1F40E;&#x1F471;&#x2764;&apos;</span>.length
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">5</mark>, still</span>
</code></pre>
<p>Before ES6, JavaScript didn&#x2019;t make any effort to figure out unicode quirks on your behalf &#x2013; you were pretty much on your own when it came to counting cards <em>(err, code points)</em>. Take for instance <code class="md-code md-code-inline">Object.keys</code>, still five code units long.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">console</span>.log(<span class="md-code-built_in">Object</span>.keys(<span class="md-code-string">&apos;<mark class="md-mark md-code-mark">&#x1F40E;&#x1F471;&#x2764;</mark>&apos;</span>))
<span class="md-code-comment">// &lt;- [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, <mark class="md-mark md-code-mark">&apos;3&apos;</mark>, <mark class="md-mark md-code-mark">&apos;4&apos;</mark>]</span>
</code></pre>
<p>If we now go back to our <code class="md-code md-code-inline">for</code> loop, we can observe how this is a problem. We actually wanted <code class="md-code md-code-inline">&apos;&#x1F40E;&apos;</code>, <code class="md-code md-code-inline">&apos;&#x1F471;&apos;</code>, <code class="md-code md-code-inline">&apos;&#x2764;&apos;</code>, but we didn&#x2019;t get that.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> text = <span class="md-code-string">&apos;<mark class="md-mark md-code-mark">&#x1F40E;&#x1F471;&#x2764;</mark>&apos;</span>
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>; i &lt; text.length; i++) {
  <span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">text[i]</mark>)
  <span class="md-code-comment">// &lt;- &apos;<mark class="md-mark md-code-mark">?</mark>&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;<mark class="md-mark md-code-mark">?</mark>&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;<mark class="md-mark md-code-mark">?</mark>&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;<mark class="md-mark md-code-mark">?</mark>&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;&#x2764;&apos;</span>
}
</code></pre>
<p>Instead, we got some weird unicode boxes &#x2013; and that&#x2019;s if we were lucky and looking at Firefox.</p>
<figure><img alt="Printing some emoji character by character on the Firefox console" class="" src="https://i.imgur.com/EhKaySs.png"></figure>
<p>That didn&#x2019;t turn out okay. In ES6 we can use the string iterator to go over the code points instead. The iterators produced by the string iterable are aware of this limitation of looping by code units, and so they <em>yield code points</em> instead.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> codePoint of <span class="md-code-string">&apos;<mark class="md-mark md-code-mark">&#x1F40E;&#x1F471;&#x2764;</mark>&apos;</span>) {
  <span class="md-code-built_in">console</span>.log(<mark class="md-mark md-code-mark">codePoint</mark>)
  <span class="md-code-comment">// &lt;- &apos;<mark class="md-mark md-code-mark">&#x1F40E;</mark>&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;<mark class="md-mark md-code-mark">&#x1F471;</mark>&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;&#x2764;&apos;</span>
}
</code></pre>
<p>If we want to measure the length, we&#x2019;d have trouble with the <code class="md-code md-code-inline">.length</code> property, as we saw earlier. We can use the iterator to <strong>split the string into its code points</strong> <em>&#x2013; as seen in the <code class="md-code md-code-inline">for..of</code> example we just went over.</em> That means the unicode-aware length of a string equals the length of the array that contains the sequence of code points produced by an iterator. We could use the <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread operator</a> to place the code points in an array, and then pull that array&#x2019;s <code class="md-code md-code-inline">.length</code>.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark">...</mark><span class="md-code-string">&apos;<mark class="md-mark md-code-mark">&#x1F40E;&#x1F471;&#x2764;</mark>&apos;</span>]<mark class="md-mark md-code-mark">.length</mark>
<span class="md-code-comment">// &lt;- 3</span>
</code></pre>
<p>Keep in mind that splitting strings into code points isn&#x2019;t enough if you want to be <em>100% precise</em> about string length. Take for instance the <a href="http://www.fileformat.info/info/unicode/char/0305/index.htm" target="_blank" rel="noopener noreferrer" aria-label="Combining Overline Unicode Character Info"><em>&#x201C;combining overline&#x201D;</em> <code class="md-code md-code-inline">\u0305</code></a> unicode code unit. On its own, this code unit is just an overline.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;\u0305&apos;</span>
<span class="md-code-comment">// &lt;- &apos; &#x305;&apos;</span>
</code></pre>
<p>When preceded by another code unit, however, they are <strong>combined together</strong> into a single glyph.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;_<mark class="md-mark md-code-mark">\u0305</mark>&apos;</span>
<span class="md-code-comment">// &lt;- &apos;_&#x305;&apos;</span>
<span class="md-code-string">&apos;foo<mark class="md-mark md-code-mark">\u0305</mark>&apos;</span>
<span class="md-code-comment">// &lt;- &apos;foo&#x305;&apos;</span>
</code></pre>
<p>Attempts to figure out the actual length by counting code points prove <strong>insufficient</strong> &#x2013; just like using <code class="md-code md-code-inline">.length</code>.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;foo<mark class="md-mark md-code-mark">\u0305</mark>&apos;</span>.length
<span class="md-code-comment">// &lt;- 4</span>
<span class="md-code-string">&apos;foo&#x305;&apos;</span>.length
<span class="md-code-comment">// &lt;- 4</span>
[<mark class="md-mark md-code-mark">...</mark><span class="md-code-string">&apos;foo&#x305;&apos;</span>]<mark class="md-mark md-code-mark">.length</mark>
<span class="md-code-comment">// &lt;- 4</span>
</code></pre>
<p>I was confused about this one as I&#x2019;m no expert when it comes to unicode. So I went to someone who <em>is</em> an expert &#x2013; <a href="https://mathiasbynens.be/" target="_blank" rel="noopener noreferrer" aria-label="You can visit him at mathiasbynens.be">Mathias Bynens</a>. He promptly pointed out that <em>&#x2013; indeed &#x2013;</em> splitting by code points isn&#x2019;t enough. Unlike surrogate pairs like the emojis we&#x2019;ve used in our earlier examples, other <em>grapheme clusters</em> aren&#x2019;t taken into account by the string iterator.</p>
<figure class="twitter-tweet-figure"><blockquote class="twitter-tweet"><p><a href="https://twitter.com/nzgb">@nzgb</a> Exactly. The string iterator iterates over code points, but not grapheme clusters. <a href="https://t.co/fTGQUOvMj8">https://t.co/fTGQUOvMj8</a></p>&#x2014; Mathias Bynens (@mathias) <a href="https://twitter.com/mathias/status/643206231214161920">September 13, 2015</a></blockquote>
</figure><p>In these cases we&#x2019;re out of luck, and we simply have to <a href="https://mathiasbynens.be/notes/javascript-unicode#other-grapheme-clusters" target="_blank" rel="noopener noreferrer" aria-label="Accounting for Grapheme Clusters">fall back to regular expressions</a> to correctly calculate the string length. For a comprehensive discussion of the subject I suggest you read his excellent <a href="https://mathiasbynens.be/notes/javascript-unicode" target="_blank" rel="noopener noreferrer" aria-label="Read it on mathiasbynens.be">&#x201C;JavaScript has a Unicode problem&#x201D;</a> piece.</p>
<p>Let&#x2019;s look at the other methods.</p>
<h1 id="stringprototypecodepointat"><code class="md-code md-code-inline">String.prototype.codePointAt</code></h1>
<p>You can use <code class="md-code md-code-inline">.codePointAt</code> to get the base-10 numeric representation of a code point at a given position in a string. Note that the position is indexed by code unit, not by code point. In the example below we print the code points for each of the three emoji in our demo <code class="md-code md-code-inline">&apos;&#x1F40E;&#x1F471;&#x2764;&apos;</code> string.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span><mark class="md-mark md-code-mark">.codePointAt(<span class="md-code-number">0</span>)</mark>
<span class="md-code-comment">// &lt;- 128014</span>
<span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span>.codePointAt(<mark class="md-mark md-code-mark">2</mark>)
<span class="md-code-comment">// &lt;- 128113</span>
<span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span>.codePointAt(<mark class="md-mark md-code-mark">4</mark>)
<span class="md-code-comment">// &lt;- 10084</span>
</code></pre>
<p>Figuring out the indices on your own may prove cumbersome, which is why you should just loop through the string iterator so that figures them out on your behalf. You can then just call <code class="md-code md-code-inline">.codePointAt(0)</code> for each code point in the sequence.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> codePoint of <span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span>) {
  <span class="md-code-built_in">console</span>.log(codePoint<mark class="md-mark md-code-mark">.codePointAt(<span class="md-code-number">0</span>)</mark>)
  <span class="md-code-comment">// &lt;- 128014</span>
  <span class="md-code-comment">// &lt;- 128113</span>
  <span class="md-code-comment">// &lt;- 10084</span>
}
</code></pre>
<p>Or maybe just use a combination of <a href="https://ponyfoo.com/articles/es6-spread-and-butter-in-depth" aria-label="ES6 Spread and Butter in Depth on Pony Foo">spread</a> and <code class="md-code md-code-inline">.map</code>.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark">...</mark><span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span>].map(<mark class="md-mark md-code-mark">cp =&gt; cp.codePointAt(<span class="md-code-number">0</span>)</mark>)
<span class="md-code-comment">// &lt;- [128014, 128113, 10084]</span>
</code></pre>
<p>You could then take the hexadecimal <em>(base-16)</em> representation of those base-10 integers and render them on a string using the new unicode code point escape syntax of <code class="md-code md-code-inline">\u{codePoint}</code>. This syntax allows you to represent unicode code points that are beyond the <em>&#x201C;basic multilingual plane&#x201D;</em> (BMP) &#x2013; i.e, code points outside the <code class="md-code md-code-inline">[U+0000, U+FFFF]</code> range that are typically represented using the <code class="md-code md-code-inline">\u1234</code> syntax.</p>
<p>Let&#x2019;s start by updating our example to print the hexadecimal version of our code points.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> codePoint of <span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span>) {
  <span class="md-code-built_in">console</span>.log(codePoint.codePointAt(<span class="md-code-number">0</span>)<mark class="md-mark md-code-mark">.toString(<span class="md-code-number">16</span>)</mark>)
  <span class="md-code-comment">// &lt;- &apos;1f40e&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;1f471&apos;</span>
  <span class="md-code-comment">// &lt;- &apos;2764&apos;</span>
}
</code></pre>
<p>You can wrap those in <code class="md-code md-code-inline">&apos;\u{codePoint}&apos;</code> and voil&#xE1; <em>&#x2013; you&#x2019;ll get the emoji out of the string once again.</em></p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;\u{1f40e}&apos;</span>
<span class="md-code-comment">// &lt;- &apos;&#x1F40E;&apos;</span>
<span class="md-code-string">&apos;\u{1f471}&apos;</span>
<span class="md-code-comment">// &lt;- &apos;&#x1F471;&apos;</span>
<span class="md-code-string">&apos;\u{2764}&apos;</span>
<span class="md-code-comment">// &lt;- &apos;&#x2764;&apos;</span>
</code></pre>
<p>Yay!</p>
<h1 id="stringfromcodepoint"><code class="md-code md-code-inline">String.fromCodePoint</code></h1>
<p>This method takes in a number and returns a code point. Note how I can use the <code class="md-code md-code-inline">0x</code> prefix with the terse base-16 code points we got from <code class="md-code md-code-inline">.codePointAt</code> moments ago.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">String</span>.fromCodePoint(<mark class="md-mark md-code-mark">0x1f40e</mark>)
<span class="md-code-comment">// &lt;- &apos;&#x1F40E;&apos;</span>
<span class="md-code-built_in">String</span>.fromCodePoint(<mark class="md-mark md-code-mark">0x1f471</mark>)
<span class="md-code-comment">// &lt;- &apos;&#x1F471;&apos;</span>
<span class="md-code-built_in">String</span>.fromCodePoint(<mark class="md-mark md-code-mark">0x2764</mark>)
<span class="md-code-comment">// &lt;- &apos;&#x2764;&apos;</span>
</code></pre>
<p>Obviously, you can just as well use their base-10 counterparts to achieve the same results.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">String</span>.fromCodePoint(<mark class="md-mark md-code-mark">128014</mark>)
<span class="md-code-comment">// &lt;- &apos;&#x1F40E;&apos;</span>
<span class="md-code-built_in">String</span>.fromCodePoint(<mark class="md-mark md-code-mark">128113</mark>)
<span class="md-code-comment">// &lt;- &apos;&#x1F471;&apos;</span>
<span class="md-code-built_in">String</span>.fromCodePoint(<mark class="md-mark md-code-mark">10084</mark>)
<span class="md-code-comment">// &lt;- &apos;&#x2764;&apos;</span>
</code></pre>
<p>You can pass in as many code points as you&#x2019;d like.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">String</span>.fromCodePoint(<mark class="md-mark md-code-mark">128014</mark>, <mark class="md-mark md-code-mark">128113</mark>, <mark class="md-mark md-code-mark">10084</mark>)
<span class="md-code-comment">// &lt;- &apos;&#x1F40E;&#x1F471;&#x2764;&apos;</span>
</code></pre>
<p>As an exercise in futility, we could map a string to their numeric representation of code points, and back to the code points themselves.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript">[...<span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span>]
  .map(cp =&gt; cp.codePointAt(<span class="md-code-number">0</span>))
  .map(cp =&gt; <span class="md-code-built_in">String</span>.fromCodePoint(cp))
  .join(<span class="md-code-string">&apos;&apos;</span>)
<span class="md-code-comment">// &lt;- &apos;&#x1F40E;&#x1F471;&#x2764;&apos;</span>
</code></pre>
<p>Maybe you&#x2019;re feeling like playing a joke on your fellow inmates &#x2013; <em>I mean, coworkers</em>. You can now stab them to death with this piece of code that doesn&#x2019;t really do anything other than converting the string into code points and then spreading those code points as parameters to <code class="md-code md-code-inline">String.fromCodePoint</code>, which in turn restores the original string. <em>As amusing as it is useless!</em></p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">String</span>.fromCodePoint(<mark class="md-mark md-code-mark">...</mark>[
  <mark class="md-mark md-code-mark">...</mark><span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span>
]<mark class="md-mark md-code-mark">.map</mark>(cp =&gt; cp<mark class="md-mark md-code-mark">.codePointAt</mark>(<span class="md-code-number">0</span>)))
<span class="md-code-comment">// &lt;- &apos;&#x1F40E;&#x1F471;&#x2764;&apos;</span>
</code></pre>
<p>Since we&#x2019;re on it, you may&#x2019;ve noticed that reversing the string itself would cause issues.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span><mark class="md-mark md-code-mark">.split(<span class="md-code-string">&apos;&apos;</span>)</mark>.reverse().join(<span class="md-code-string">&apos;&apos;</span>)
</code></pre>
<p>The problem is that you&#x2019;re reversing individual code units as opposed to code points.</p>
<figure><img alt="Reversing individual code units ends up breaking the code points" class="" src="https://i.imgur.com/KctK6mu.png"></figure>
<p>If we were to use the spread operator to split the string by its code points, and then reverse that, the code points would be preserved and the string would be properly reversed.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript">[<mark class="md-mark md-code-mark">...</mark><span class="md-code-string">&apos;\ud83d\udc0e\ud83d\udc71\u2764&apos;</span>].reverse().join(<span class="md-code-string">&apos;&apos;</span>)
<span class="md-code-comment">// &lt;- &apos;&#x2764;&#x1F471;&#x1F40E;&apos;</span>
</code></pre>
<p>This way we avoid breaking code points, but once again keep in mind that this won&#x2019;t work for <em>all</em> grapheme clusters, as Mathias pointed out in his tweet.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript">[...<span class="md-code-string">&apos;foo<mark class="md-mark md-code-mark">\u0305</mark>&apos;</span>].reverse().join(<span class="md-code-string">&apos;&apos;</span>)
<span class="md-code-comment">// &lt;- <mark class="md-mark md-code-mark">&apos; &#x305;oof&apos;</mark></span>
</code></pre>
<p>The last method we&#x2019;ll cover today is <code class="md-code md-code-inline">.normalize</code>.</p>
<h1 id="stringprototypenormalize"><code class="md-code md-code-inline">String.prototype.normalize</code></h1>
<p>There&#x2019;s different ways to represent strings that look identical to humans, even though their code points differ. Mathias gives an example as follows.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ma&#xF1;ana&apos;</span> === <span class="md-code-string">&apos;man&#x303;ana&apos;</span>
<span class="md-code-comment">// &lt;- false</span>
</code></pre>
<p>What&#x2019;s going on here? We have a combining tilde <a href="https://codepoints.net/U+0303" target="_blank" rel="noopener noreferrer" aria-label="U+0303 COMBINING TILDE"><code class="md-code md-code-inline">&#x303;</code></a> and an <a href="https://codepoints.net/U+006E" target="_blank" rel="noopener noreferrer" aria-label="U+006E LATIN SMALL LETTER N"><code class="md-code md-code-inline">n</code></a> on the right, while the left just has an <a href="https://codepoints.net/U+00F1" target="_blank" rel="noopener noreferrer" aria-label="U+00F1 LATIN SMALL LETTER N WITH TILDE"><code class="md-code md-code-inline">&#xF1;</code></a>. These <a href="https://mathiasbynens.be/notes/javascript-unicode#accounting-for-lookalikes" target="_blank" rel="noopener noreferrer" aria-label="Accounting for lookalikes">look alike</a>, but if you look at the code points you&#x2019;ll notice they&#x2019;re different.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript">[...<span class="md-code-string">&apos;ma&#xF1;ana&apos;</span>].map(cp =&gt; cp.codePointAt(<span class="md-code-number">0</span>).toString(<span class="md-code-number">16</span>))
<span class="md-code-comment">// &lt;- [&apos;6d&apos;, &apos;61&apos;, <mark class="md-mark md-code-mark">&apos;f1&apos;</mark>, &apos;61&apos;, &apos;6e&apos;, &apos;61&apos;]</span>
[...<span class="md-code-string">&apos;man&#x303;ana&apos;</span>].map(cp =&gt; cp.codePointAt(<span class="md-code-number">0</span>).toString(<span class="md-code-number">16</span>))
<span class="md-code-comment">// &lt;- [&apos;6d&apos;, &apos;61&apos;, <mark class="md-mark md-code-mark">&apos;6e&apos;, &apos;303&apos;</mark>, &apos;61&apos;, &apos;6e&apos;, &apos;61&apos;]</span>
</code></pre>
<p>Just like with the <code class="md-code md-code-inline">&apos;foo&#x305;&apos;</code> example, the second string has a length of <code class="md-code md-code-inline">7</code>, even though it is <code class="md-code md-code-inline">6</code> glyphs long.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;ma&#xF1;ana&apos;</span>.length
<span class="md-code-comment">// &lt;- 6</span>
<span class="md-code-string">&apos;man&#x303;ana&apos;</span>.length
<span class="md-code-comment">// &lt;- 7</span>
</code></pre>
<p>If we normalize the second version, we&#x2019;ll get back the same code points we had in the first version.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">var</span> normalized = <span class="md-code-string">&apos;man&#x303;ana&apos;</span><mark class="md-mark md-code-mark">.normalize()</mark>
[...normalized].map(cp =&gt; cp.codePointAt(<span class="md-code-number">0</span>).toString(<span class="md-code-number">16</span>))
<span class="md-code-comment">// &lt;- [&apos;6d&apos;, &apos;61&apos;, <mark class="md-mark md-code-mark">&apos;f1&apos;</mark>, &apos;61&apos;, &apos;6e&apos;, &apos;61&apos;]</span>
normalized.length
<span class="md-code-comment">// &lt;- 6</span>
</code></pre>
<p>Just for completeness&#x2019; sake, note that you can represent these code points using the <code class="md-code md-code-inline">&apos;\x6d&apos;</code> syntax.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-string">&apos;\\x&apos;</span> + [...<span class="md-code-string">&apos;ma&#xF1;ana&apos;</span>].map(cp =&gt; cp.codePointAt(<span class="md-code-number">0</span>).toString(<span class="md-code-number">16</span>)).join(<span class="md-code-string">&apos;\\x&apos;</span>)
<span class="md-code-comment">// &lt;- &apos;\\x6d\\x61\\xf1\\x61\\x6e\\x61&apos;</span>
<span class="md-code-string">&apos;\x6d\x61\xf1\x61\x6e\x61&apos;</span>
<span class="md-code-comment">// &lt;- &apos;ma&#xF1;ana&apos;</span>
</code></pre>
<p>We could use <code class="md-code md-code-inline">.normalize</code> on both strings to see if they&#x2019;re really equal.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">compare</span> <span class="md-code-params">(left, right)</span> </span>{
  <span class="md-code-keyword">return</span> left.normalize() === right.normalize()
}
compare(<span class="md-code-string">&apos;ma&#xF1;ana&apos;</span>, <span class="md-code-string">&apos;man&#x303;ana&apos;</span>)
<span class="md-code-comment">// &lt;- true</span>
</code></pre>
<p>Or, to prove the point in something that&#x2019;s a bit more visible to human eyes, let&#x2019;s use the <code class="md-code md-code-inline">\x</code> syntax. Note that you can only use <code class="md-code md-code-inline">\x</code> to represent code units with codes below 256 <em>(<code class="md-code md-code-inline">\xff</code> is <code class="md-code md-code-inline">255</code>)</em>. For anything larger than that we should use the <code class="md-code md-code-inline">\u</code> escape. Such is the case of the <a href="https://codepoints.net/U+006E" target="_blank" rel="noopener noreferrer" aria-label="U+006E LATIN SMALL LETTER N"><code class="md-code md-code-inline">U+0303</code></a> combining tilde.</p>
<pre class="md-code-block"><code class="md-code md-lang-javascript">compare(
  <span class="md-code-string">&apos;\x6d\x61<mark class="md-mark md-code-mark">\xf1</mark>\x61\x6e\x61&apos;</span>,
  <span class="md-code-string">&apos;\x6d\x61<mark class="md-mark md-code-mark">\x6e\u0303</mark>\x61\x6e\x61&apos;</span>
)
<span class="md-code-comment">// &lt;- true</span>
</code></pre>
<p>See you tomorrow? <em>Modules are coming.</em></p>
<blockquote>
<p><em>Many thanks to Mathias for reviewing drafts of this article</em>, &#x2764;!</p>
</blockquote></div>
