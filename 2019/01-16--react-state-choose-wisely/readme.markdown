<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/react-state-choose-wisely">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/react-state-choose-wisely"><div><img src="https://images.ponyfoo.com/uploads/hero-653e892333e74c7da5dae18d006e915a.jpg" alt="React State: Choose Wisely"></div></a>

<h1>React State: Choose Wisely</h1>

<p><kbd>javascript</kbd> <kbd>react</kbd> <kbd>redux</kbd></p>

<blockquote><p>Proper state handling in React will make your components simple and maintainable. Poor choices will give you lots of headaches in the long-term.</p><p>There are plenty of &#x2026;</p></blockquote>

<div><p>Proper state handling in React will make your components simple and maintainable. Poor choices will give you lots of headaches in the long-term.</p></div>

<blockquote></blockquote>

<div><p>There are plenty of options for managing state in a React app. But there&#x2019;s very little guidance about which one you should use in any situation.</p> <p>Let&#x2019;s fix that.</p> <p>The solution you pick to manage state should fit they way you want to <em>use</em> the items you hold in state. Your choice should also make it easy for you to update, reuse, and refactor your code. In other words, your choice of state management can make your life easy or hard.</p></div>

<div><p>Here&#x2019;s a non-exhaustive list of things you should consider:</p> <ol> <li>How quickly can you add new state code?</li> <li>How well encapsulated is your stateful data?</li> <li>How easy is it to pull the data into a new component?</li> </ol> <p>Let&#x2019;s use this list as a basis for comparing different ways of handling state. To do this, we&#x2019;ll make the same simple component using three different forms of state handling. By making the same thing three ways, you&#x2019;ll get a few nice perspectives.</p> <p>First, you&#x2019;ll see that any approach can solve any problem. This is important because if you know that you can solve nearly any problem with any form of state management, you can turn your attention from the technical problem of getting it working, to the more abstract problem of making it work well in your over all application.</p> <p>Second, by making the same thing three ways, you&#x2019;ll start to see the subtle differences which can become big headaches as an applications grows.</p> <p>What are the three ways to manage state?</p> <ol> <li><strong>Local State</strong>: State stored directly on the component.</li> <li><strong>Global State</strong>: A global store. In this example, you&#x2019;ll use redux.</li> <li><strong>Context</strong>: A newer API that lets you access state higher up the tree.</li> </ol> <p>Using the three points of comparison and the three ways of managing state, you&#x2019;ll be able to build a nice table that will let you compare the different options.</p> <table> <thead> <tr> <th></th> <th>Local</th> <th>Global</th> <th>Context</th> </tr> </thead> <tbody> <tr> <td>Easy</td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> </tr> <tr> <td>Encapsulated</td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> </tr> <tr> <td>Available</td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> </tr> </tbody> </table> <p>Alright. Let&#x2019;s get started.</p> <p>You&#x2019;ll be making a very simple counter. It&#x2019;s just two things: the current count and a button to add to the current count. As mentioned you&#x2019;ll have one for each type of state, but they all act exactly the same way.</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/initial-e9c8dcc3726a4acba76a8f445c1fac9c.gif"></figure> <p>So far, nothing too exciting. The first thing you are going to do is make the presentation layer. This will be a simple reusable component that displays the count and the button. Making this independent is not only a good practice, it will also a show you how easy it is to swap different forms of state handling.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Display</span><span class="md-code-params">({ addOne, count, title})</span> </span>{
  <span class="md-code-keyword">return</span>(
    <span><span class="md-code-tag">&lt;<span class="md-code-title">div</span> <span class="md-code-attribute">className</span>=<span class="md-code-value">&quot;counter&quot;</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">h3</span>&gt;</span>{title}<span class="md-code-tag">&lt;/<span class="md-code-title">h3</span>&gt;</span>
      Current Count: {count}
      <span class="md-code-tag">&lt;<span class="md-code-title">button</span> <span class="md-code-attribute">onClick</span>=<span class="md-code-value">{addOne}</span>&gt;</span> Add One! <span class="md-code-tag">&lt;/<span class="md-code-title">button</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  )
}
</span></code></pre> <p>Now that you have your basic display component, you can start to build the stateful components.</p> <h3 id="local-state">Local State</h3> <p>The first component you&#x2019;ll build will store state locally, directly on the component.</p> <p>All you need is a basic class with <code class="md-code md-code-inline">state</code> as a property and a method to add to state. Pass both the <code class="md-code md-code-inline">count</code> from the state object and the <code class="md-code md-code-inline">addOne()</code> method into your presentation component and you&#x2019;re all done.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React, { Component } from <span class="md-code-string">&apos;react&apos;</span>;
import Display from <span class="md-code-string">&apos;../Display/Display&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-keyword">class</span> StateCounter extends Component {
  state = {
    count: <span class="md-code-number">0</span>
  }

  addOne = () =&gt; {
    <span class="md-code-keyword">this</span>.setState(state =&gt; ({count: state.count + <span class="md-code-number">1</span>}))
  }

  render() {
    <span class="md-code-keyword">return</span> (
      <span><span class="md-code-tag">&lt;<span class="md-code-title">Display</span>
        <span class="md-code-attribute">addOne</span>=<span class="md-code-value">{this.addOne}</span>
        <span class="md-code-attribute">count</span>=<span class="md-code-value">{this.state.count}</span>
        <span class="md-code-attribute">title</span>=<span class="md-code-value">&quot;Local Counter&quot;</span>
      /&gt;</span>
    )
  }
}
</span></code></pre> <p>At this point, one thing should jump out: it&#x2019;s easy. Even without knowing much about other forms of state handling, you can see this one is very simple to set up. But it gets even better.</p> <p>With the introduction of <a href="https://medium.com/r/?url=https%3A%2F%2Freactjs.org%2Fdocs%2Fhooks-overview.html" target="_blank" rel="noopener noreferrer">React Hooks</a>, you&#x2019;ll remove nearly all the boilerplate code.</p> <p>Here&#x2019;s an updated version using React hooks that&#x2019;s nearly identical to the official docs:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React, { useState } from <span class="md-code-string">&apos;react&apos;</span>;
import Display from <span class="md-code-string">&apos;../Display/Display&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">StateCounterHooks</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">const</span> [count, add] = useState(<span class="md-code-number">0</span>);
  <span class="md-code-keyword">const</span> addOne = () =&gt; add(count + <span class="md-code-number">1</span>);
  <span class="md-code-keyword">return</span> (
    <span><span class="md-code-tag">&lt;<span class="md-code-title">Display</span>
      <span class="md-code-attribute">addOne</span>=<span class="md-code-value">{addOne}</span>
      <span class="md-code-attribute">count</span>=<span class="md-code-value">{count}</span>
      <span class="md-code-attribute">title</span>=<span class="md-code-value">&quot;Local Counter&quot;</span>
    /&gt;</span>
  )
}
</span></code></pre> <p>As above, <code class="md-code md-code-inline">count</code> is the stateful data, and <code class="md-code md-code-inline">add()</code> is a method for updating state. It would really be difficult to make this easier.</p> <h3 id="global-state">Global State</h3> <p>The next component you&#x2019;ll build will use a global store. In this example, you&#x2019;ll use redux since it&#x2019;s by far the most popular, but many of the issues would be the same if you were using other options like MobX or even Apollo and GraphQL.</p> <p>We&#x2019;ll move quickly past some of the complexities of implementing redux. If you need a refresher, check out the <a href="https://medium.com/r/?url=https%3A%2F%2Fredux.js.org%2F" target="_blank" rel="noopener noreferrer">official docs</a>.</p> <p>To start make an action to add an item to the global store.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">export <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> ({
    type: <span class="md-code-string">&apos;ADD_ONE&apos;</span>,
  })
}
</code></pre> <p>Next, make a reducer to actually store the count.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">count</span><span class="md-code-params">(state = 0, action)</span> </span>{
  <span class="md-code-keyword">switch</span> (action.type) {
    <span class="md-code-keyword">case</span> <span class="md-code-string">&apos;ADD_ONE&apos;</span>:
      <span class="md-code-keyword">return</span> state + <span class="md-code-number">1</span>;
    <span class="md-code-keyword">default</span>:
      <span class="md-code-keyword">return</span> state;
  }
}

export <span class="md-code-keyword">default</span> combineReducers({
  count,
})
</code></pre> <p>If you&#x2019;ve worked with redux before you may have ignored this part, but it&#x2019;s important to take a moment to think about what you just did here.</p> <p>You just created a global state object with the a property of <code class="md-code md-code-inline">count</code>&#xA0;. That property name is now unique for this particular action. If you wanted to create another property with a similar name you&#x2019;d need to either give it a unique name such as <code class="md-code md-code-inline">clickCount</code> or encapsulate one, the other, or both inside a nested object.</p> <p>You&#x2019;ll return to this idea in a bit. For now, use <code class="md-code md-code-inline">connect</code> to pull the state into your display component.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import { connect } from <span class="md-code-string">&apos;react-redux&apos;</span>

import { add } from <span class="md-code-string">&apos;../../store/actions&apos;</span>;
import Display from <span class="md-code-string">&apos;../Display/Display&apos;</span>;

export <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">ReduxCounter</span><span class="md-code-params">({ addOne, count })</span> </span>{
  <span class="md-code-keyword">return</span>(
    <span><span class="md-code-tag">&lt;<span class="md-code-title">Display</span>
      <span class="md-code-attribute">addOne</span>=<span class="md-code-value">{addOne}</span>
      <span class="md-code-attribute">count</span>=<span class="md-code-value">{count}</span>
      <span class="md-code-attribute">title</span>=<span class="md-code-value">&quot;Redux Counter&quot;</span>
    /&gt;</span>
  )
}

const mapStateToProps = ({ count }) =&gt; ({ count });

const mapDispatchToProps = { addOne: add }

export default connect(mapStateToProps, mapDispatchToProps)(ReduxCounter);
</span></code></pre> <p>Again, we won&#x2019;t explore the details, but as a summary, the component is tapping into the global store so that you can both read from it, using <code class="md-code md-code-inline">mapStateToProps</code>, and update it using <code class="md-code md-code-inline">mapDispatchToProps</code>. Other than that, your display component doesn&#x2019;t care where the data comes from.</p> <p>So far, the thing that should jump out immediately is how much work is involved. There are more files, more imports, more complexity. That&#x2019;s not a problem if the advantages outweigh the extra work&#x200A;&#x2014;&#x200A;and they often will&#x200A;&#x2014;&#x200A;but it is still something to consider.</p> <h3 id="context">Context</h3> <p>The final component will use context. This is a fairly new form of state handling that was introduced in React 16.3. Context is similar to local state in many ways, but it has a slightly different implementation.</p> <p>To start off, you need to create a context. This will set up a couple defaults that you will use when you create an implementation.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;

<span class="md-code-keyword">const</span> CounterContext = React.createContext({
  addOne(){},
  counter: <span class="md-code-number">0</span>,
});

export <span class="md-code-keyword">default</span> CounterContext;
</code></pre> <p>This sets the initial state of <code class="md-code md-code-inline">0</code> and adds a noop function that you will override later.</p> <p>To actually use context, you will first need to make a <strong>Provider</strong>. A provider is the base component that will hold the state object and the methods for updating the state.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React, { Component } from <span class="md-code-string">&apos;react&apos;</span>;
import CounterContext from <span class="md-code-string">&apos;./CounterContext&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-keyword">class</span> ContextProvider extends Component {
  state = {
    count: <span class="md-code-number">0</span>,
  }

  addOne = () =&gt; {
    <span class="md-code-keyword">this</span>.setState(state =&gt; ({count: state.count + <span class="md-code-number">1</span>}))
  }
  
  render() {
    <span class="md-code-keyword">const</span> { count } = <span class="md-code-keyword">this</span>.state;

    <span class="md-code-keyword">const</span> value = {
      addOne: <span class="md-code-keyword">this</span>.addOne,
      count,
    };

    <span class="md-code-keyword">return</span> (
      <span><span class="md-code-tag">&lt;<span class="md-code-title">CounterContext.Provider</span> <span class="md-code-attribute">value</span>=<span class="md-code-value">{value}</span>&gt;</span>
        {this.props.children}
      <span class="md-code-tag">&lt;/<span class="md-code-title">CounterContext.Provider</span>&gt;</span>
    )
  }
}
</span></code></pre> <p>If you scroll up, you&#x2019;ll notice this looks very similar to the local state component. The big difference is that you are combing the state and the update function in single object which you then pass down into a <strong>Provider</strong> component that wraps everything else. In this case, you are wrapping <code class="md-code md-code-inline">this.props.children</code> but you can also wrap a component directly.</p> <p>To use this component, you&#x2019;d wrap some other components. In this case, you&#x2019;ll wrap a single component.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">
import React from <span class="md-code-string">&apos;react&apos;</span>;
import CounterProvider from <span class="md-code-string">&apos;../ContextCounter/CounterProvider&apos;</span>;
import OtherComponent from <span class="md-code-string">&apos;../ContextCounter/OtherComponent&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Counter</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span>(
    <span><span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">CounterProvider</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">OtherComponent</span> /&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">CounterProvider</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  )
}
</span></code></pre> <p>Notice, you are not passing any props to <code class="md-code md-code-inline">OtherComponent</code>&#xA0;. More clearly, you are not <em>explicitly</em> passing anything to <code class="md-code md-code-inline">OtherComponent</code>. The provider is holding the state information so that you can tap into it later.</p> <p>Even if you go several components deep, you will still be able to access the provider&#x2019;s state. So if <code class="md-code md-code-inline">OtherComponent</code> returns another component:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import AnotherComponent from <span class="md-code-string">&apos;./AnotherComponent&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">OtherComponent</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span>(
    <span><span class="md-code-tag">&lt;<span class="md-code-title">AnotherComponent</span> /&gt;</span>
  )
}
</span></code></pre> <p>And <code class="md-code md-code-inline">AnotherComponent</code> returns yet <em>another</em> component. That information is still hanging in the background.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import ContextDisplay from <span class="md-code-string">&apos;./ContextDisplay&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">AnotherComponent</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span>(
    <span><span class="md-code-tag">&lt;<span class="md-code-title">ContextDisplay</span> /&gt;</span>
  )
}
</span></code></pre> <p>Ok, that&#x2019;s far enough. It&#x2019;s time to pull out the state and do something with it.</p> <p>To get the information you need to create a <strong>Consumer</strong>. The consumer uses render props to pull out that single value object. Remember, <code class="md-code md-code-inline">value</code> contains <code class="md-code md-code-inline">count</code> and <code class="md-code md-code-inline">addOne</code>&#xA0;. You can use destructuring as a short hand.</p> <p>Now that you have the state and the function to update state, you can pass it into your display component:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import CounterContext from <span class="md-code-string">&apos;./CounterContext&apos;</span>;
import Display from <span class="md-code-string">&apos;../Display/Display&apos;</span>

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">ContextDisplay</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span>(
    <span><span class="md-code-tag">&lt;<span class="md-code-title">CounterContext.Consumer</span>&gt;</span>
      {({ addOne, count}) =&gt; {
        return (
          <span class="md-code-tag">&lt;<span class="md-code-title">Display</span>
            <span class="md-code-attribute">addOne</span>=<span class="md-code-value">{addOne}</span>
            <span class="md-code-attribute">count</span>=<span class="md-code-value">{count}</span>
            <span class="md-code-attribute">title</span>=<span class="md-code-value">&quot;Context Counter&quot;</span>
          /&gt;</span>
        )
      }}
    <span class="md-code-tag">&lt;/<span class="md-code-title">CounterContext.Consumer</span>&gt;</span>
  )
}
</span></code></pre> <h3 id="comparisons">Comparisons</h3> <p>As you saw, any form of state handling can do the same thing. In reality, if you put effort into it, you can make any state handling system work for any piece of data in your application.</p> <p>Of course, who wants to put effort into it? The goal is always less effort, better results. With that in mind, it&#x2019;s time to compare the different approaches.</p> <h3 id="simplicity">Simplicity</h3> <p>This is the easiest comparison. Nothing beats local state particularly when you use React hooks. It&#x2019;s quick, it does that job and it&#x2019;s easy to refactor into a more complicated system if necessary. As a rule, you should always start with local state. If you need something more complicated, you can refactor as you go.</p> <p>For this reason, Local State wins for simplicity.</p> <table> <thead> <tr> <th></th> <th>Local</th> <th>Global</th> <th>Context</th> </tr> </thead> <tbody> <tr> <td>Easy</td> <td>&#x2705;</td> <td>&#x274E;</td> <td>&#x274E;</td> </tr> <tr> <td>Encapsulated</td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> </tr> <tr> <td>Available</td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> </tr> </tbody> </table> <h3 id="encapsulation">Encapsulation</h3> <p>Next, let&#x2019;s explore how well the data is encapsulated. If data is well encapsulated, you can reuse a component multiple times without any concern that another component may accidentally change your state. Encapsulation isn&#x2019;t necessarily a goal in itself. There are times where you absolutely want different components to access and modify shared data (more on that in the next section).</p> <p>As with most things, it&#x2019;s about predictability. If you expect a component to be independent, the data shouldn&#x2019;t be open to modifications by other components.</p> <p>To explore encapsulation, you&#x2019;ll need to add multiple versions of a component to see how they interact.</p> <p>To start off return to the original page that has all three components.</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/multicount-26b623cdb35448a4a979a51799f41c2b.gif"></figure> <p>The code looks something like this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import StateCounter from <span class="md-code-string">&apos;../StateCounter/StateCounterHooks&apos;</span>;
import ReduxCounter from <span class="md-code-string">&apos;../ReduxCounter/ReduxCounter&apos;</span>;
import CounterProvider from <span class="md-code-string">&apos;../ContextCounter/CounterProvider&apos;</span>;
import OtherComponent from <span class="md-code-string">&apos;../ContextCounter/OtherComponent&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Counter</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span>(
    <span><span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">StateCounter</span> /&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">ReduxCounter</span> /&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">CounterProvider</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">OtherComponent</span> /&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">CounterProvider</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  )
}
</span></code></pre> <p>You have a simple parent component that wraps one instance of each component. To test encapsulation, all you need to do is add a second instance.</p> <p>Start off with the <code class="md-code md-code-inline">StateCounter</code> component. The updated code looks like this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import StateCounter from <span class="md-code-string">&apos;../StateCounter/StateCounterHooks&apos;</span>;
import ReduxCounter from <span class="md-code-string">&apos;../ReduxCounter/ReduxCounter&apos;</span>;
import CounterProvider from <span class="md-code-string">&apos;../ContextCounter/CounterProvider&apos;</span>;
import OtherComponent from <span class="md-code-string">&apos;../ContextCounter/OtherComponent&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Counter</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span>(
    <span><span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">StateCounter</span> /&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">StateCounter</span> /&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">ReduxCounter</span> /&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">CounterProvider</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">OtherComponent</span> /&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">CounterProvider</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  )
}
</span></code></pre> <p>When you open that in the browser, you can easily see that the data is well encapsulated. Every time you click the add button, it only updates that count on that particular component.</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/doublelocal-2621a9c3317a4193b1a3bc77a5f2e907.gif"></figure> <p>Now try adding a second redux component.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import StateCounter from <span class="md-code-string">&apos;../StateCounter/StateCounterHooks&apos;</span>;
import ReduxCounter from <span class="md-code-string">&apos;../ReduxCounter/ReduxCounter&apos;</span>;
import CounterProvider from <span class="md-code-string">&apos;../ContextCounter/CounterProvider&apos;</span>;
import OtherComponent from <span class="md-code-string">&apos;../ContextCounter/OtherComponent&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Counter</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span>(
    <span><span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">StateCounter</span> /&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">ReduxCounter</span> /&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">ReduxCounter</span> /&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">CounterProvider</span>&gt;</span>
          <span class="md-code-tag">&lt;<span class="md-code-title">OtherComponent</span> /&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">CounterProvider</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  )
}
</span></code></pre> <p>Open this in the browser and notice how different it is. Every time you click on **Add&#xA0;**, you update the data on both components.</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/doubleglobal-d6e57f1ba52d49e4b2507e2af0c71a93.gif"></figure> <p>In this case, these components are not independent. You can alter the data in any component that use the same action.</p> <p>Now, there are certainly ways around this. You can have an <code class="md-code md-code-inline">id</code> on the global store for each component. You can use an array. You can use a different namespace. But the fact is that global stores are best for global data. Encapsulation is not a primary goal.</p> <p>How about context? Well, this is were things get a little more tricky. What does it mean to add a second component? Does that mean you add a second consumer? In this case, that would mean adding a second <code class="md-code md-code-inline">OtherComponent</code> under the same provider. Or do you add a second <code class="md-code md-code-inline">CounterProvider</code>?</p> <p>Why not both? First, add another provider. Then in the existing provider, add a second instance of <code class="md-code md-code-inline">OtherComponent</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import React from <span class="md-code-string">&apos;react&apos;</span>;
import StateCounter from <span class="md-code-string">&apos;../StateCounter/StateCounter&apos;</span>;
import ReduxCounter from <span class="md-code-string">&apos;../ReduxCounter/ReduxCounter&apos;</span>;
import CounterProvider from <span class="md-code-string">&apos;../ContextCounter/CounterProvider&apos;</span>;
import OtherComponent from <span class="md-code-string">&apos;../ContextCounter/OtherComponent&apos;</span>;

export <span class="md-code-keyword">default</span> <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">Counter</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span>(
    <span><span class="md-code-tag">&lt;<span class="md-code-title">div</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">StateCounter</span> /&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">ReduxCounter</span> /&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">CounterProvider</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">OtherComponent</span> /&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">CounterProvider</span>&gt;</span>
      <span class="md-code-tag">&lt;<span class="md-code-title">CounterProvider</span>&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">OtherComponent</span> /&gt;</span>
        <span class="md-code-tag">&lt;<span class="md-code-title">OtherComponent</span> /&gt;</span>
      <span class="md-code-tag">&lt;/<span class="md-code-title">CounterProvider</span>&gt;</span>
    <span class="md-code-tag">&lt;/<span class="md-code-title">div</span>&gt;</span>
  )
}
</span></code></pre> <p>Let&#x2019;s see what happens.</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/multicontext-7ab077100e344cdcb678ad43de92ee08.gif"></figure> <p>When you click on the first component, the counter iterates, but the other counters do not. But when you click on the second context counter, it <em>will</em> change the third counter. Similarily, if you click on the third counter, it will change the second.</p> <p>This means that context is somewhere in the middle. It can be encapsulated when you want it to be, and it can be global when you want it to be.</p> <p>Now, this claim comes with a big caveat. The ability to share date or keep it private all depends on how you order the components. Anything in the same hierarchy as the provider will share data, anything outside will not. This means that you may have to move providers up or down depending on how you want to use the consumers.</p> <p>Still, at this point, you can finish filling out the chart. Local state is well encapsulated and context can be. They each get a check. Global state is not well encapsulated to it does not get credit.</p> <table> <thead> <tr> <th></th> <th>Local</th> <th>Global</th> <th>Context</th> </tr> </thead> <tbody> <tr> <td>Easy</td> <td>&#x2705;</td> <td>&#x274E;</td> <td>&#x274E;</td> </tr> <tr> <td>Encapsulated</td> <td>&#x2705;</td> <td>&#x274E;</td> <td>&#x2705;</td> </tr> <tr> <td>Available</td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> <td><code class="md-code md-code-inline">?</code></td> </tr> </tbody> </table> <h3 id="availability">Availability</h3> <p>That just leaves one more area of concern: availability. The beauty part is that you don&#x2019;t need to write any more code. Sometimes you want your data to be easy to access.</p> <p>Consider a shopping cart. Pushing users to a sale is the most important thing your code can do. Consequently, nearly every part of your app will potentially need to know about the cart (how much is in it, the total, etc). This is data you want to make easily accessible.</p> <p>In this case, you can use what you learned above. Local state, for example, could work, but you would have to store it so far up the component hierarchy that you&#x2019;d be passing it down a lot of props.</p> <p>Global state, on the other hand, was designed specifically for this. It&#x2019;s an easy thumbs up &#x1F44D;.</p> <p>Context as you saw above can either be global (at least depending on where you put it in the hierarchy) or encapsulated. Go ahead and give it credit.</p> <p>The final comparison looks like this:</p> <table> <thead> <tr> <th></th> <th>Local</th> <th>Global</th> <th>Context</th> </tr> </thead> <tbody> <tr> <td>Easy</td> <td>&#x2705;</td> <td>&#x274E;</td> <td>&#x274E;</td> </tr> <tr> <td>Encapsulated</td> <td>&#x2705;</td> <td>&#x274E;</td> <td>&#x2705;</td> </tr> <tr> <td>Available</td> <td>&#x274E;</td> <td>&#x2705;</td> <td>&#x2705;</td> </tr> </tbody> </table> <p>One thing that&#x2019;s not reflected in this chart is the large collection of third-party code that ties in with a global store. If you want to use observables with your store, then you&#x2019;re better off using <a href="https://medium.com/r/?url=https%3A%2F%2Fgithub.com%2Fredux-observable%2Fredux-observable" target="_blank" rel="noopener noreferrer">redux-observables</a> than trying to roll your own solution.</p> <h3 id="building-and-refactoring">Building and Refactoring</h3> <p>You may look at this table and think that local state or context are somehow better. That&#x2019;s not true. The best solution is the one that works best for your data and your app.</p> <p>Still, there are a few common patterns that may help the decision making process.</p> <p>First, always start with local state. As you saw above, local state is the easiest to build and prototype. When you start with local state you don&#x2019;t have to deal with all the complexities of setting up a <code class="md-code md-code-inline">Provider</code> or writing actions and reducers. Even if you plan on moving to a more widely available state management, local state is a great way prove your concept.</p> <p>Next, use context if you want to maximize reusability and local state is not sufficient. After you go through the hard work of building a component, you&#x2019;ll want to reuse it as much as possible. That may even mean reusing it across different project and teams.</p> <p>By choosing context, you reduce the number of additional dependencies your independent component will need. In other words, it will be much easier to drop the new component into an existing project. The component will be internally independent. You gain all the advantages of widely available components while avoiding extra code.</p> <p>Finally, don&#x2019;t worry about the rules. If your team uses global state and has a well defined structure in place, you&#x2019;ll do more harm by using a different solution. Internal consistency and clear communication should always be the first priority. If your new component breaks the pattern, you may save yourself a few minutes of coding, but your teammates will lose their ability to quickly skim and understand a component. New patterns aren&#x2019;t bad, but they should add value.</p> <p>Each of these solutions exist for a reason. Your job is to find the fit that makes your code easiest to build and maintain.</p></div>
