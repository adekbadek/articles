<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/graphql-in-depth-what-why-and-how">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/graphql-in-depth-what-why-and-how"><div><img src="https://images.unsplash.com/photo-1505686994434-e3cc5abf1330?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1352&amp;q=80" alt="GraphQL in Depth: What, Why, and How"></div></a>

<h1>GraphQL in Depth: What, Why, and How</h1>

<p><kbd>graphql</kbd> <kbd>apollo</kbd></p>

<blockquote><p>Stop wondering if GraphQL is right for you and give it a spin! Learn about types, queries, and mutations in this in-depth walkthrough.</p>
</blockquote>

<div><p>GraphQL is all the rage, but what exactly is it? In this in-depth walkthrough, we take a look at what GraphQL is, how to use it, and why you should use it.</p></div>

<blockquote></blockquote>

<div><p>Learn why GraphQL is all the rage! We&#x2019;ll walk through the implementation of a schema for a popcorn company&#x2019;s API, learning about types, queries, and mutations as we go.</p></div>

<div><p>I love popcorn. &#x1F37F;</p> <p>As I&#x2019;m writing this, I&#x2019;m snacking on a bowl of multi-colored kernels, lightly seasoned with Flavacol (hint: this is the movie theater&#x2019;s secret) and I&#x2019;m feeling a twinge of hubris in my eye&#x2026;</p> <p>&#x201C;I should start a popcorn company&#x2026;&#x201D;</p> <p>Well, that&#x2019;s a terrible idea, Ryan! But, for the sake of this tutorial, it&#x2019;s <em>the best idea you&#x2019;ve had all week</em>. <strong>In this tutorial, we&#x2019;re going to learn how to create a simple, GraphQL-based API for a popcorn company</strong>.</p> <p>All we need is a name. Seeing as how I&#x2019;m quite fond of sarcasm, how about&#x2026;</p> <p><em>Sarcastic Kernels: The Popcorn You Love to Hate to Eat&#x2122;</em></p> <p>Perfect! And like any self-respecting nerd, it only seems right to start writing some code before we come up with a sound business plan. To get started, let&#x2019;s wrap our heads around what GraphQL is and how it compares to REST.</p> <h1 id="what-is-graphql">What is GraphQL?</h1> <p>GraphQL is a client-side query language coupled with a pattern &#x2014; formally known as a &#x201C;schema&#x201D; &#x2014; for organizing the creation, reading, updating, and deleting of data in your application (yeah, that CRUD).</p> <p>We say &#x201C;application&#x201D;, here, and not database because GraphQL is data-source-agnostic, meaning it doesn&#x2019;t care <em>where</em> your data lives.</p> <p>From the outside looking in, GraphQL can seem quite scary. Does the &#x201C;Graph&#x201D; part mean I have to learn about graph databases? Does the QL (query language) mean I have to learn I have to learn a brand new programming language?!</p> <p>Not quite. To calm your nerves, the harsh truth is: GraphQL is just a dressed up <code class="md-code md-code-inline">GET</code> or <code class="md-code md-code-inline">POST</code> request.</p> <p>Wait, what?!</p> <p>Yep. While GraphQL as a whole <em>does</em> introduce some new concepts for organizing and interacting with your data, behind the curtain, GraphQL still relies on a good ol&#x2019; fashioned HTTP request to do its magic.</p> <h3 id="rethinking-rest">Rethinking REST</h3> <p>Where GraphQL separates from a more familiar REST API is due to its <em>flexibility</em>. With REST, done properly, endpoints are typically designed from the perspective of a resource, or, a type of data in our application.</p> <p>For example, a <code class="md-code md-code-inline">GET</code> request to <code class="md-code md-code-inline">/api/v1/flavors</code> would be expected to send us back a response that looks something like this:</p> <pre class="md-code-block"><code class="md-code md-lang-json">[
  {
   &quot;<span class="md-code-attribute">id</span>&quot;: <span class="md-code-value"><span class="md-code-number">1</span></span>,
    &quot;<span class="md-code-attribute">name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;The Lazy Person&apos;s Movie Theater&quot;</span></span>,
    &quot;<span class="md-code-attribute">description</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!&quot;</span>
  </span>}, {
    &quot;<span class="md-code-attribute">id</span>&quot;: <span class="md-code-value"><span class="md-code-number">2</span></span>,
    &quot;<span class="md-code-attribute">name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;What&apos;s Wrong With You Caramel&quot;</span></span>,
    &quot;<span class="md-code-attribute">description</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;You&apos;re a crazy person that likes sweet popcorn. Congratulations.&quot;</span>
  </span>}, {
    &quot;<span class="md-code-attribute">id</span>&quot;: <span class="md-code-value"><span class="md-code-number">3</span></span>,
    &quot;<span class="md-code-attribute">name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;Gnarly Chili Lime&quot;</span></span>,
    &quot;<span class="md-code-attribute">description</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;The kind of popcorn you make when you need a good smack in the face.&quot;</span></span>}
]
</code></pre> <p>Now, there&#x2019;s nothing terribly wrong with this, but let&#x2019;s consider our UI, or rather, how we intend to <em>consume</em> this data.</p> <p>If we wanted to display a simple list UI where all we had were the kinds of popcorn that are available (and nothing else), we might end up with a design like the one below.</p> <figure><img alt="" class="" src="https://cleverbeagle-cdn.s3.amazonaws.com/ponyfoo/graphql-example-list-ui.png"></figure> <p>And&#x2026; we&#x2019;d be in a bit of a jam. We can choose not to use the <code class="md-code md-code-inline">description</code> field, sure, but are we just going to sit around and act like we <em>didn&#x2019;t</em> send that to the client as well?!</p> <p>Haha! What do you think this is? <em>Fantasy land</em>? Of course we are! And when someone asks &#x201C;why is the app so slow for users?&#x201D; in a few months, we&#x2019;ll just say &#x201C;be right back, going to grab a coffee!&#x201D; and then split town, never to be seen again.</p> <p>It&#x2019;s not entirely our fault, though. To be fair, REST <em>is</em> the data-fetching equivalent of going to a restaurant and being asked &#x201C;What do you want? We&#x2019;ll give you what we have.&#x201D;</p> <p>Jokes aside, in a real application this can be problematic. For example, we may display different traits for each kind of popcorn like pricing information, brand details, or dietary restrictions (&#x201C;vegan popcorn!&#x201D;). Rigid REST endpoints make delivering specific traits based on context a headache, leading to unnecessary performance overhead and frustration.</p> <h2 id="how-graphql-improves-rest">How GraphQL improves REST</h2> <p>On the surface, this may seem like a small problem. &#x201C;Who cares if we&#x2019;re sending unnecessary data to the client?&#x201D; Well, let&#x2019;s add some context. GraphQL was invented at Facebook. Facebook serves millions of requests <em>per second</em>.</p> <p>Translation? Every optimization counts.</p> <p>Instead of saying &#x201C;here&#x2019;s what&#x2019;s available,&#x201D; <strong>GraphQL inverts the problem and asks &#x201C;what do you need?&#x201D;</strong></p> <p>We can get back a response from GraphQL specific to the context where we&#x2019;re consuming data <em>without</em> having to add a one-off endpoint, perform multiple requests, or write convoluted conditional code.</p> <h1 id="how-does-graphql-work">How does GraphQL work?</h1> <p>Like we hinted at above, at it&#x2019;s core GraphQL relies on a simple <code class="md-code md-code-inline">GET</code> or <code class="md-code md-code-inline">POST</code> request for moving data to and <em>from</em> the client. Unpacking that, GraphQL has two types of requests when it comes to reading (the R in CRUD), creating, updating, and deleting (The CUD in CRUD): queries and mutations.</p> <p>All of those queries and mutations are sent as either a <code class="md-code md-code-inline">GET</code> or <code class="md-code md-code-inline">POST</code> request to a GraphQL server at a URL like <code class="md-code md-code-inline">https://myapp.com/graphql</code>. More on that below.</p> <h3 id="understanding-queries">Understanding Queries</h3> <p>Queries are what you&#x2019;d expect: a request for some data. We have the UI, and we need to fill it with data, so we make a <em>query</em> to the server. With a traditional REST API, our query would come in the form of a GET request. With GraphQL, we introduce a new syntax for requesting data:</p> <pre class="md-code-block"><code class="md-code">{
  flavors {
    name
  }
}
</code></pre> <p>Wait, you mean JSON? Or is that a JavaScript object?</p> <p>Neither.</p> <p>The &#x201C;QL&#x201D; part of GraphQL stands for <em>query language</em>. Quite literally, this is a brand new language for writing data queries. That sounds more complicated than it is. Let&#x2019;s break down the above query.</p> <pre class="md-code-block"><code class="md-code">{
  // The fields we want to query are written here.
}
</code></pre> <p>All queries start from the &#x201C;root query&#x201D; and are known as fields. To save yourself a headache: it&#x2019;s best to refer to this as &#x201C;query fields in my schema.&#x201D; Don&#x2019;t fret, we&#x2019;ll learn more about how those are defined in a bit. Here, we ask to query the <code class="md-code md-code-inline">flavors</code> field on the root query.</p> <pre class="md-code-block"><code class="md-code">{
  flavors {
    // The sub-fields we want for each flavor are written here.
  }
}
</code></pre> <p>When querying a field, we also need to specify the sub-fields we want for each object in the response (even if we expect just a single object to be returned).</p> <pre class="md-code-block"><code class="md-code">{
  flavors {
    name
  }
}
</code></pre> <p>The end result? When we send this query to a GraphQL server, we get back a neat, tidy response like this:</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">data</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">flavors</span>&quot;: <span class="md-code-value">[
      { &quot;<span class="md-code-attribute">name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;The Lazy Person&apos;s Movie Theater&quot;</span> </span>},
      { &quot;<span class="md-code-attribute">name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;What&apos;s Wrong With You Caramel&quot;</span> </span>},
      { &quot;<span class="md-code-attribute">name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;Gnarly Chili Lime&quot;</span> </span>}
    ]
  </span>}
</span>}
</code></pre> <p>Neat, right? To make this clear, if we ran the following query on another page:</p> <pre class="md-code-block"><code class="md-code">{
  flavors {
    id
    name
    description
  }
}
</code></pre> <p>we&#x2019;d get back a response like this:</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;data&quot;: {
    &quot;flavors&quot;: [
      { &quot;id&quot;: 1, &quot;name&quot;: &quot;The Lazy Person&apos;s Movie Theater&quot;, description: &quot;That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!&quot; },
      { &quot;id&quot;: 2, &quot;name&quot;: &quot;What&apos;s Wrong With You Caramel&quot;, description: &quot;You&apos;re a crazy person that likes sweet popcorn. Congratulations.&quot; },
      { &quot;id&quot;: 3, &quot;name&quot;: &quot;Gnarly Chili Lime&quot;, description: &quot;A friend told me this would taste good. It didn&apos;t. It burned my kernels. I haven&apos;t had the heart to tell him.&quot; }
    ]
  }
}
</code></pre> <p>Super powerful! <em>Same endpoint, with a different response tailored to the context</em>.</p> <p>If we wanted to get a single flavor, GraphQL queries accept arguments, too:</p> <pre class="md-code-block"><code class="md-code">{
  flavors(id: &quot;1&quot;) {
    id
    name
    description
  }
}
</code></pre> <p>Here, we&#x2019;ve hardcoded the specific <code class="md-code md-code-inline">id</code> of a flavor we want to query, but we can also have a dynamic <code class="md-code md-code-inline">id</code>:</p> <pre class="md-code-block"><code class="md-code">query getFlavor($id: ID) {
  flavors(id: $id) {
    id
    name
    description
  }
}
</code></pre> <p>On the first line, we give our query a name (this is arbitrary; we could replace <code class="md-code md-code-inline">getFlavor</code> with <code class="md-code md-code-inline">pizza</code> and this would still work) and define the variables that query expects. Here, we expect a possible variable <code class="md-code md-code-inline">id</code> to be passed as an <code class="md-code md-code-inline">ID</code> scalar type (more on these below).</p> <p>Regardless of using a static or dynamic <code class="md-code md-code-inline">id</code> to make our request, here&#x2019;s the response we can expect:</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;data&quot;: {
    &quot;flavors&quot;: [
      { &quot;id&quot;: 1, &quot;name&quot;: &quot;The Lazy Person&apos;s Movie Theater&quot;, description: &quot;That elusive flavor that you begrudgingly carted yourself to the theater for, now in the comfort of your own home, you slob!&quot; }
    ]
  }
}
</code></pre> <p>Nice! Hopefully your hamster is starting to spin. This is already great, but where GraphQL really starts to shine is with <em>nested fields</em>. Let&#x2019;s assume we had another field in our schema called <code class="md-code md-code-inline">nutrition</code> that told us just how unhealthy our sarcastic kernels are:</p> <pre class="md-code-block"><code class="md-code">{
  flavors {
    id
    name
    nutrition {
      calories
      fat
      sodium
    }
  }
}
</code></pre> <p>What this <em>may</em> look like is us having a nested <code class="md-code md-code-inline">nutrition</code> object on each of our <code class="md-code md-code-inline">flavors</code>. Not quite! With GraphQL, we can combine separate but related data sources into a single query, getting a response that gives us the benefit of nested data without having to denormalize everything in the database:</p> <pre class="md-code-block"><code class="md-code md-lang-json">{
  &quot;<span class="md-code-attribute">data</span>&quot;: <span class="md-code-value">{
    &quot;<span class="md-code-attribute">flavors</span>&quot;: <span class="md-code-value">[
      {
        &quot;<span class="md-code-attribute">id</span>&quot;: <span class="md-code-value"><span class="md-code-number">1</span></span>,
        &quot;<span class="md-code-attribute">name</span>&quot;: <span class="md-code-value"><span class="md-code-string">&quot;The Lazy Person&apos;s Movie Theater&quot;</span></span>,
        &quot;<span class="md-code-attribute">nutrition</span>&quot;: <span class="md-code-value">{
          &quot;<span class="md-code-attribute">calories</span>&quot;: <span class="md-code-value"><span class="md-code-number">500</span></span>,
          &quot;<span class="md-code-attribute">fat</span>&quot;: <span class="md-code-value"><span class="md-code-number">12</span></span>,
          &quot;<span class="md-code-attribute">sodium</span>&quot;: <span class="md-code-value"><span class="md-code-number">1000</span>
        </span>}
      </span>},
      ...
    ]
  </span>}
</span>}
</code></pre> <p>That&#x2019;s a serious boon on productivity. But what about <em>updating</em> data, does GraphQL give the same advantages?</p> <h3 id="understanding-mutations">Understanding Mutations</h3> <p>Where <em>queries</em> fetch data, <em>mutations</em> are responsible for making changes to data. Alternatively, too, mutations can be used for a generic RPC (remote procedure call) for miscellaneous tasks like sending a user&#x2019;s data to a third-party API.</p> <pre class="md-code-block"><code class="md-code">mutation updateFlavor($id: ID!, $name: String, $description: String) {
  updateFlavor(id: $id, name: $name, description: $description) {
    id
    name
    description
  }
}
</code></pre> <p>Mutations rely on a similar syntax to queries. Here, we define a mutation <code class="md-code md-code-inline">updateFlavor</code> with some variables: <code class="md-code md-code-inline">id</code>, <code class="md-code md-code-inline">name</code>, and <code class="md-code md-code-inline">description</code>. Just like with our queries, we &#x201C;wrap&#x201D; a mutation field (defined on a similar <em>root mutation</em>) using the keyword <code class="md-code md-code-inline">mutation</code>, followed by a name describing the mutation and a set of variables to pass along.</p> <p>Those variables include <em>what we&#x2019;re trying to change</em> or <em>mutate</em>. Notice, too, that after executing a mutation, we can ask for some fields <em>back</em>.</p> <p>In this case, we want to get back the <code class="md-code md-code-inline">id</code>, <code class="md-code md-code-inline">name</code>, and <code class="md-code md-code-inline">description</code> <em>after</em> they&#x2019;ve been mutated. This helps with things like optimistic UI, negating the need for a request following the update.</p> <h3 id="writing-a-schema-and-attaching-it-to-a-graphql-server">Writing a schema and attaching it to a GraphQL server</h3> <p>So far, what we&#x2019;ve been looking at is how GraphQL functions <em>on the client</em>. This is how we <em>make</em> requests, but how do we respond to them?</p> <h4 id="the-graphql-server">The GraphQL server</h4> <p>In order to make a GraphQL request, we need to have a GraphQL <em>server</em> to send it to. A GraphQL server is a regular ol&#x2019; HTTP server (if you&#x2019;re a JavaScripter, think Express or Hapi) with a GraphQL <em>schema</em> attached to it.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import express from <span class="md-code-string">&apos;express&apos;</span>
import graphqlHTTP from <span class="md-code-string">&apos;express-graphql&apos;</span>
import schema from <span class="md-code-string">&apos;./schema&apos;</span>

<span class="md-code-keyword">const</span> app = express()

app.use(<span class="md-code-string">&apos;/graphql&apos;</span>, graphqlHTTP({
  schema: schema,
  graphiql: <span class="md-code-literal">true</span>
}))

app.listen(<span class="md-code-number">4000</span>)
</code></pre> <p>By &#x201C;attached,&#x201D; we mean that requests received by that server are passed through the schema and then back to the client, kind of like an air filter in your house.</p> <p>The &#x201C;filtering&#x201D; process that takes place is relative to the query or mutation you send from the client. Both queries and mutations are <em>resolved</em> using functions associated with the fields defined on our <em>root query</em> or <em>root mutation</em> in our schema.</p> <p>Above, we can see a mock HTTP server being created with the JavaScript library Express. Utilizing the <code class="md-code md-code-inline">graphqlHTTP</code> function from the <code class="md-code md-code-inline">express-graphql</code> package by Facebook, we &#x201C;attach&#x201D; our schema (here, assumed to be defined in another file) and start our server on port <code class="md-code md-code-inline">4000</code> (i.e., <code class="md-code md-code-inline">http://localhost:4000/graphql</code> is where we&#x2019;ll send requests from the client).</p> <h4 id="types-and-resolvers">Types and resolvers</h4> <p>With a running server, we need to define the schema that we attach to it.</p> <p>Recall that earlier, we talked about defining <em>fields</em> on either a <em>root query</em> or <em>root mutation</em>.</p> <pre class="md-code-block"><code class="md-code">import gql from &apos;graphql-tag&apos;
import mongodb from &apos;/path/to/mongodb&#x2019; // For example. Assuming `mongodb` gives us a MongoDB connection.

const schema = {
  typeDefs: gql`
    type Nutrition {
      flavorId: ID
      calories: Int
      fat: Int
      sodium: Int
    }

    type Flavor {
      id: ID
      name: String
      description: String
      nutrition: Nutrition
    }

    type Query {
      flavors(id: ID): [Flavor]
    }

    type Mutation {
      updateFlavor(id: ID!, name: String, description: String): Flavor
    }
  `,
  resolvers: {
    Query: {
      flavors: (parent, args) =&gt; {
        // Assuming args equals an object like { id: &apos;1&apos; }
        return mongodb.collection(&apos;flavors&apos;).find(args).toArray()
      },
    },
    Mutation: {
      updateFlavor: (parent, args) =&gt; {
        // Assuming args equals an object like { id: &apos;1&apos;, name: &apos;Movie Theater Clone&apos;, description: &apos;Bring the movie theater taste home!&apos; }

        // Perform the update.
        mongodb.collection(&apos;flavors&apos;).update(args)

        // Return the flavor after the update.
        return mongodb.collection(&apos;flavors&apos;).findOne(args.id)
      },
    },
    Flavor: {
      nutrition: (parent) =&gt; {
        return mongodb.collection(&apos;nutrition&apos;).findOne({
          flavorId: parent.id,
        })
      }
    },
  },
}

export default schema
</code></pre> <p>When it comes to defining fields in a GraphQL schema, there are two parts: <code class="md-code md-code-inline">typeDefs</code> and <code class="md-code md-code-inline">resolvers</code>.</p> <p><code class="md-code md-code-inline">typeDefs</code> contain the <em>type definitions</em> for the data in our application. For example, earlier we talked about retrieving a list of <code class="md-code md-code-inline">flavors</code>. In order to do that, we need to do three things:</p> <ol> <li>Tell our schema what a flavor&#x2019;s data looks like (above, by defining the <code class="md-code md-code-inline">type Flavor</code> type).</li> <li>Define a field on the root <code class="md-code md-code-inline">type Query</code> field (above, the <code class="md-code md-code-inline">flavors</code> property on the <code class="md-code md-code-inline">type Query</code> value).</li> <li>Define a <em>resolver function</em> on the <code class="md-code md-code-inline">resolvers.Query</code> object corresponding to the field we defined on the root <code class="md-code md-code-inline">type Query</code> field.</li> </ol> <p>Focusing on the <code class="md-code md-code-inline">typeDefs</code>, this is where we tell our schema about the <em>shape</em> of our data. In other words, we tell GraphQL about the different properties a piece of data might contain.</p> <pre class="md-code-block"><code class="md-code">type Flavor {
  id: ID
  name: String
  description: String
  nutrition: Nutrition
}
</code></pre> <p>The <code class="md-code md-code-inline">type Flavor</code> definition says that &#x201C;a flavor can contain an <code class="md-code md-code-inline">id</code> as an <code class="md-code md-code-inline">ID</code>, a <code class="md-code md-code-inline">name</code> as a <code class="md-code md-code-inline">String</code>, a <code class="md-code md-code-inline">description</code> as a <code class="md-code md-code-inline">String</code>, and <code class="md-code md-code-inline">nutrition</code> as <code class="md-code md-code-inline">Nutrition</code>.&#x201D;</p> <p>For that last one, <code class="md-code md-code-inline">nutrition</code>, we pass the name of <em>another type defined in our <code class="md-code md-code-inline">typeDefs</code></em>. Here, <code class="md-code md-code-inline">type Nutrition</code> describes how nutrition data is shaped in our application.</p> <blockquote> <p>Notice that we&#x2019;re not saying in our database. A database is assumed in the example above, but your data can come from <em>any</em> data source. Even a third-party API or a static file!</p> </blockquote> <p>Just like we did for <code class="md-code md-code-inline">type Flavor</code> we specify the names of the field a piece of <code class="md-code md-code-inline">nutrition</code> data will have, assigning what GraphQL refers to as <em>scalar types</em> to each property. As of writing, GraphQL recognizes <a href="https://graphql.org/learn/schema/#scalar-types" target="_blank" rel="noopener noreferrer">five built-in scalar types</a>:</p> <ul> <li><code class="md-code md-code-inline">Int</code>: A signed 32&#x2010;bit integer.</li> <li><code class="md-code md-code-inline">Float</code>: A signed double-precision floating-point value.</li> <li><code class="md-code md-code-inline">String</code>: A UTF&#x2010;8 character sequence.</li> <li><code class="md-code md-code-inline">Boolean</code>: <code class="md-code md-code-inline">true</code> or <code class="md-code md-code-inline">false</code>.</li> <li><code class="md-code md-code-inline">ID</code>: A unique identifier, often used to refetch an object or as the key for a cache. The ID type is serialized in the same way as a String; however, defining it as an ID signifies that it is not intended to be human&#x2010;readable.</li> </ul> <p>In addition to these scalar types, we can also assign <em>custom types</em> to a property like we did with the <code class="md-code md-code-inline">Nutrition</code> type on the <code class="md-code md-code-inline">nutrition</code> property of the <code class="md-code md-code-inline">type Flavor</code> above.</p> <pre class="md-code-block"><code class="md-code">type Query {
  flavors(id: ID): [Flavor]
}
</code></pre> <p>On our root <code class="md-code md-code-inline">type Query</code> (the &#x201C;root query&#x201D; we talked about earlier), we define the name of a <em>field</em> that can be queried. When defining that field, too, we specify any arguments we might expect along with the type of data we expect to be returned.</p> <p>In this example, we expect a possible <code class="md-code md-code-inline">id</code> argument to be passed as an <code class="md-code md-code-inline">ID</code> scalar type and expect an array of objects resembling the <code class="md-code md-code-inline">Flavor</code> type in response.</p> <h3 id="wiring-up-a-query-resolver">Wiring up a query resolver</h3> <p>With our <code class="md-code md-code-inline">flavors</code> field defined on our root <code class="md-code md-code-inline">type Query</code>, next, we define what&#x2019;s known as a <em>resolver function</em>.</p> <p>This is where GraphQL more or less &#x201C;stops.&#x201D; If we look in the <code class="md-code md-code-inline">resolvers</code> object of our schema file and then in the <code class="md-code md-code-inline">Query</code> object nested under that, we can see a property <code class="md-code md-code-inline">flavors</code> assigned to a function. This <code class="md-code md-code-inline">flavors</code> here is the <em>resolver function</em> for the <code class="md-code md-code-inline">flavors</code> field defined on our root <code class="md-code md-code-inline">type Query</code>.</p> <pre class="md-code-block"><code class="md-code">typeDefs: gql`&#x2026;`,
resolvers: {
  Query: {
    flavors: (parent, args) =&gt; {
      // Assuming args equals an object like { id: &apos;1&apos; }
      return mongodb.collection(&apos;flavors&apos;).find(args).toArray()
    },
  },
  &#x2026;
},
</code></pre> <p>This resolver function takes a few different arguments: the <code class="md-code md-code-inline">parent</code> query if one exists, the <code class="md-code md-code-inline">args</code> passed to the query if any exist, and a missing <code class="md-code md-code-inline">context</code> argument which gives us miscellaneous &#x201C;context&#x201D; data (e.g., the current user if we provide them when our server starts).</p> <p>Inside our resolver, we do <em>whatever we need to do to resolve the query</em>. This is where GraphQL &#x201C;quits caring&#x201D; and leaves retrieving and returning data up to us. Again, this could be a call to a database, an API, a static file&#x2026;<em>anything</em>.</p> <blockquote> <p>While GraphQL doesn&#x2019;t care where our data comes from, it _does _ care about what we return. We can return a JSON object, an array of JSON objects, or a Promise (which GraphQL will resolve for us).</p> </blockquote> <p>Here, we use a mock call to a MongoDB database collection called <code class="md-code md-code-inline">flavors</code>, passing in our <code class="md-code md-code-inline">args</code> (if any exist) to a <code class="md-code md-code-inline">.find()</code> call and returning what it finds as an array.</p> <h3 id="resolving-nested-fields">Resolving nested fields</h3> <p>What may not be clear above is how our nested <code class="md-code md-code-inline">nutrition</code> data is resolved. Remember: we&#x2019;re not actually storing the nutrition data <em>on</em> each <code class="md-code md-code-inline">flavor</code> but assume it lives in another databse collection/table.</p> <p>While we <em>did</em> tell GraphQL that our <code class="md-code md-code-inline">type Flavor</code> might include some <code class="md-code md-code-inline">nutrition</code> data in the shape of the <code class="md-code md-code-inline">type Nutrition</code>, we didn&#x2019;t explain how to actually <em>resolve</em> that data. Again: <strong>the <code class="md-code md-code-inline">nutrition</code> data for a flavor is assumed to be in a different collection than the flavor data</strong>.</p> <pre class="md-code-block"><code class="md-code">  typeDefs: gql`
    type Nutrition {
      flavorId: ID
      calories: Int
      fat: Int
      sodium: Int
    }

    type Flavor {
      [&#x2026;]
      nutrition: Nutrition
    }

    type Query {&#x2026;}

    type Mutation {&#x2026;}
  `,
  resolvers: {
    Query: {
      flavors: (parent, args) =&gt; {&#x2026;},
    },
    Mutation: {&#x2026;},
    Flavor: {
      nutrition: (parent) =&gt; {
        return mongodb.collection(&apos;nutrition&apos;).findOne({
          flavorId: parent.id,
        })
      }
    },
  },
</code></pre> <p>If we look close at the <code class="md-code md-code-inline">resolvers</code> object on our schema, notice that we have <code class="md-code md-code-inline">Query</code>, <code class="md-code md-code-inline">Mutation</code>, and <code class="md-code md-code-inline">Flavor</code>. These correspond to the types we defined in the <code class="md-code md-code-inline">typeDefs</code> above.</p> <p>Looking at the <code class="md-code md-code-inline">Flavor</code> object, we can see the field <code class="md-code md-code-inline">nutrition</code> being defined as a <em>resolver function</em>. What&#x2019;s unique about this is that we&#x2019;re defining this _on the <code class="md-code md-code-inline">Flavor</code> type directly. In other words, we&#x2019;re saying &#x201C;this is how we want you to resolve the <code class="md-code md-code-inline">nutrition</code> field for any queries utilizing the <code class="md-code md-code-inline">type Flavor</code>.&#x201D;</p> <p>Inside, we do a familiar MongoDB query, but notice that we utilize the <code class="md-code md-code-inline">parent</code> argument passed to the resolver function. The <code class="md-code md-code-inline">parent</code> here is each iteration of the <code class="md-code md-code-inline">flavors</code> field. For example, if we ask for all flavors at once like this:</p> <pre class="md-code-block"><code class="md-code">{
  flavors {
    id
    name
    nutrition {
      calories
    }
  }
}
</code></pre> <p>For each <code class="md-code md-code-inline">flavor</code> returned by <code class="md-code md-code-inline">flavors</code>, we&#x2019;d pass it through the <code class="md-code md-code-inline">nutrition</code> resolver defined on <code class="md-code md-code-inline">resolvers.Flavor</code> as <code class="md-code md-code-inline">parent</code>. If we look close, we can see that we utilize the <code class="md-code md-code-inline">parent.id</code> field, referring to the <code class="md-code md-code-inline">id</code> of the flavor we&#x2019;re currently iterating (looping) over.</p> <p>We pass that <code class="md-code md-code-inline">parent.id</code> to our database query, matching it to a (presumed) <code class="md-code md-code-inline">flavorId</code> property on each <code class="md-code md-code-inline">nutrition</code> item.</p> <h3 id="wiring-up-mutations">Wiring up mutations</h3> <p>Conveniently, our knowledge of wiring up queries maps over perfectly to mutations. In fact, the process is nearly identical. If we take a look at our root <code class="md-code md-code-inline">type Mutation</code>, we can see that we define a field <code class="md-code md-code-inline">updateFlavor</code> accepting the arguments we specified on the client:</p> <pre class="md-code-block"><code class="md-code">type Mutation {
  updateFlavor(id: ID!, name: String, description: String): Flavor
}
</code></pre> <p>Here, we&#x2019;re saying &#x201C;we expect the <code class="md-code md-code-inline">updateFlavor</code> mutation to accept a possible <code class="md-code md-code-inline">id</code> as an <code class="md-code md-code-inline">ID</code> (the <code class="md-code md-code-inline">!</code> tells GraphQL that this is <em>required</em>), <code class="md-code md-code-inline">name</code> as a <code class="md-code md-code-inline">String</code>, and <code class="md-code md-code-inline">description</code> as a <code class="md-code md-code-inline">String</code>.&#x201D; Additionally, once our mutation completes, we expect some data in return resembling the <code class="md-code md-code-inline">Flavor</code> type (i.e., containing an <code class="md-code md-code-inline">id</code>, <code class="md-code md-code-inline">name</code>, <code class="md-code md-code-inline">description</code>, and/or <code class="md-code md-code-inline">nutrition</code>).</p> <pre class="md-code-block"><code class="md-code">{
  typeDefs: gql`&#x2026;`,
  resolvers: {
    Mutation: {
      updateFlavor: (parent, args) =&gt; {
        // Assuming args equals an object like { id: &apos;1&apos;, name: &apos;Movie Theater Clone&apos;, description: &apos;Bring the movie theater taste home!&apos; }

        // Perform the update.
        mongodb.collection(&apos;flavors&apos;).update(
          { id: args.id },
          {
            $set: {
              ...args,
            },
          },
        )

        // Return the flavor after the update.
        return mongodb.collection(&apos;flavors&apos;).findOne(args.id)
      },
    },
  },
}
</code></pre> <p>Inside our resolver function for the <code class="md-code md-code-inline">updateFlavor</code> mutation, we do what you might expect: interact with our database to change or <em>update</em> the flavor.</p> <p>Notice that immediately after we perform the update, we make a call back to our database to find the same flavor again and return it from our resolver. Why?</p> <p>Remember: on the client, we expect a return value <em>after</em> our mutation completes. In this example, we expect the <code class="md-code md-code-inline">flavor</code> we just updated to be returned.</p> <p>Couldn&#x2019;t we just return the <code class="md-code md-code-inline">args</code> object? Yep! We could. The reason we choose <em>not</em> to in this case is that we want to be 100% certain our database update succeeded. If we go fetch the data again and see that it&#x2019;s changed: all is well!</p> <h1 id="why-would-i-want-to-use-graphql">Why would I want to use GraphQL?</h1> <p>Though it may not look like much, at this point we have a functioning&#x2014;albeit simple&#x2014;GraphQL API up and running!</p> <p>As with any new tech, though, what may not be abundantly clear is why you&#x2019;d even want to use this. To be fair, this <em>is</em> a lot of moving parts. Why shouldn&#x2019;t we just stick to REST or talking to the database directly?</p> <h3 id="you-want-to-reduce-the-number-of-requests-made-from-the-client">You want to reduce the number of requests made from the client</h3> <p>Where a lot of apps get bogged down is in the number, frequency, and complexity of HTTP requests. While GraphQL doesn&#x2019;t completely eliminate requests, utilized properly, it can <em>significantly</em> reduce the number of requests you make from the client (in many cases, down to just one).</p> <p>Whether you&#x2019;re running an app with tons of users or an app with lots of data (e.g., an app for handling medical records), using GraphQL will definitely speed up client performance.</p> <h3 id="you-want-to-avoid-denormalizing-data-just-to-compensate-the-ui">You want to avoid denormalizing data just to compensate the UI</h3> <p>In applications with a lot of relational data, the &#x201C;denormalization trap&#x201D; can be quite common. While this works, it&#x2019;s by no means ideal and can slow things down unnecessarily. With GraphQL and nested queries, the need to denormalize your data is significantly reduced.</p> <h3 id="you-have-multiple-data-sources-to-talk-to-from-different-apps">You have multiple data sources to talk to from different apps</h3> <p>This problem can be solved in part with a traditional REST API, but it still leaves a problem: consistent querying from the client. Assuming you have a product with a web app, iOS app, Android app, and developer API, it&#x2019;s likely that you&#x2019;ll have to rig up querying <em>for each of those platforms</em>.</p> <p>This translates to developing knowledge of multiple client implementations for HTTP requests, an inconsistent means for performing queries, and messy, platform-specific endpoints in your API (don&#x2019;t you &#x201C;holier than thou&#x201D; me, friend, you know you&#x2019;ve done this before!).</p> <h2 id="is-graphql-perfect-should-i-ditch-my-rest-api-today-and-switch-to-it">Is GraphQL perfect? Should I ditch my REST API today and switch to it?</h2> <p>Of course not! <em>Nothing is perfect</em>.</p> <p>Where GraphQL most obviously falls short is its complexity. Writing a GraphQL schema introduces a lot of <em>mandatory</em> steps in order to wire up your data. As you&#x2019;re learning, this can be frustrating because what is missing from your schema may not always be obvious and errors on the client and server may be unhelpful.</p> <p>Further, consuming GraphQL on the client is not standardized beyond the GraphQL query language. Different libraries exists for this, the most popular being Apollo and Relay, each with their own idiosyncrasies.</p> <p>GraphQL is also just a specification. Packages like <code class="md-code md-code-inline">graphql</code> (used internally by the <code class="md-code md-code-inline">express-graphql</code> package from our examples) are just an <em>implementation</em> of that specification. In other words, different implementations for different programming languages may interpret the specification differently. This can lead to problems for you and your team if you use multiple languages across projects.</p> <p>GraphQL is an impressive step forward in handling data, though. It&#x2019;s by no means a silver bullet, but it&#x2019;s certainly worth experimenting with. A great way to get started is to think about a particularly messy part of your data process and try to implement it using GraphQL.</p> <p>This is the great news: GraphQL can be implemented incrementally. <em>You don&#x2019;t have to go all in to start taking advantage of it</em>. This is a great way to get buy in from your team and stakeholders and create an opportunity to get your hands dirty.</p> <p>Keep in mind: GraphQL is ultimately just a tool for doing a job. It&#x2019;s not &#x201C;killing&#x201D; anything. That said, it&#x2019;s worth familiarizing yourself with it and starting to apply in your apps. Anywhere you struggle with performance overhead or complex UIs like data dashboards, news feeds, and user profiles is a great place to get started.</p> <p>Happy coding!</p></div>
