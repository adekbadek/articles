<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/action-pattern-clean-obvious-testable-code">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/action-pattern-clean-obvious-testable-code"><div><img src="https://images.ponyfoo.com/uploads/deer-3955031_1920-1eadcb53528f4432a5006edf55814203.jpg" alt="The Action Pattern: Clean, Obvious, Testable Code"></div></a>

<h1>The Action Pattern: Clean, Obvious, Testable Code</h1>

<p><kbd>patterns</kbd> <kbd>action-pattern</kbd></p>

<blockquote><p>Let&#x2019;s convert a mock API endpoint for signing up new users in a mobile app into using the action pattern.</p>
</blockquote>

<div><p>Let&#x2019;s convert a mock API endpoint for signing up new users in a mobile app into using the action pattern.</p></div>

<blockquote></blockquote>

<div><p>When I first started writing software on the web, my code was a mishmash. Every project was loaded with unnecessarily long files and code left commented, thrown to the side of the road like an abandoned vehicle. The theme of the day was: unpredictability.</p> <p>Under ideal conditions&#x2014;the happy path&#x2014;I was able to make my code work. But what I couldn&#x2019;t do was make my code work <em>consistently</em>. One time through my code would work, then the next an anonymous <code class="md-code md-code-inline">500 Internal Server Error</code> would send me spiraling for days.</p> <p>I was able to squeak by, but the thought of having to continue answering emails from clients that read &#x201C;this isn&#x2019;t working&#x2026;&#x201D; was a life I didn&#x2019;t want to lead.</p> <p>Taking off my beginner&#x2019;s hat, I started to see what other, more experienced programmers were up to. I&#x2019;d heard about Bob &#x201C;Uncle Bob&#x201D; Martin in passing, eventually discovering <a href="https://cleancoders.com/videos/clean-code/fundamentals" target="_blank" rel="noopener noreferrer">his Clean Coders series</a>. I was hooked. For the first time, he was answering questions others on my path hadn&#x2019;t.</p></div>

<div><p>My primary question? &#x201C;How do I organize complex code?&#x201D; As far as questions go that was a ball of yarn, but over several videos he explained the parts I was missing:</p> <ul> <li>Using explicit names that can&#x2019;t be mistaken.</li> <li>Breaking your code into functions that do one thing.</li> <li>Using TDD (test-driven development) to guide yout work.</li> </ul> <p>Still green, some of this made sense and some of it didn&#x2019;t. The other problem was that Bob&#x2019;s language of choice was Java, not <em>JavaScript</em>. This meant that I was able to grasp what he was saying at a high level, but practically I was still stumped.</p> <h3 id="several-iterations-later">Several iterations later&#x2026;</h3> <p>Eventually, what Bob taught started to sink in. As I gained experience, I slowly started to organize my code into a pattern (supported by a short list of rules):</p> <ol> <li>Any code that involves multiple steps should be moved into its own file/module.</li> <li>That file/module should be given a name that describes what those steps lead up to.</li> <li>Each step in that code should be a single function with a name that describes exactly what it does (even if it&#x2019;s longer than we prefer).</li> <li>If the code fails, it should be easy to see exactly <em>where</em> it failed without a lot of backstepping.</li> </ol> <p>What started out as an informal set of rules for myself eventually evolved into a concrete pattern. After years of iteration and putting it through the paces on client and personal projects, in 2017 the action pattern was christened.</p> <h3 id="how-actions-work">How Actions work</h3> <p>For the remainder of this tutorial, we&#x2019;re going to convert a mock API endpoint for signing up new users in a mobile app into an action. Our goals:</p> <ol> <li>Understand the structure of an action.</li> <li>Learn how to use JavaScript Promises with actions.</li> <li>Find a greater &#x201C;why&#x201D; for using actions.</li> <li>Understand how writing tests is simplified by using actions.</li> </ol> <h2 id="converting-our-existing-api-endpoint">Converting Our Existing API Endpoint</h2> <p>Our app, Doodler (a paid social network for artists), handles its signups via an existing Express-based API. When a new user signs up in the app, a request is made to their API at <code class="md-code md-code-inline">https://doodler.fake/api/v1/users/signup</code>.</p> <p>At that endpoint, the following steps take place:</p> <ul> <li>A new user is created in the users collection.</li> <li>A new customer is created on Stripe.</li> <li>A customer is created in the customers collection.</li> <li>A welcome email is generated.</li> <li>A &#x201C;new user&#x201D; message is sent to the company&#x2019;s Slack.</li> </ul> <p>Together, these five steps represent the <em>action</em> of signing up a new user. Because some of the steps are dependent on prior steps, we want to have some way to &#x201C;stop&#x201D; our code if earlier steps fail. Before we get into the weeds, let&#x2019;s take a look at the code we have now:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">/* eslint-disable */</span>

import mongodb from <span class="md-code-string">&apos;/path/to/mongodb&apos;</span>;
import settings from <span class="md-code-string">&apos;/path/to/settings&apos;</span>;
import stripe from <span class="md-code-string">&apos;/path/to/stripe/api&apos;</span>;
import imaginaryEmailService from <span class="md-code-string">&apos;/path/to/imaginaryEmailService&apos;</span>;
import slackLog from <span class="md-code-string">&apos;/path/to/slackLog&apos;</span>;

export <span class="md-code-keyword">default</span> {
  v1: {
    <span class="md-code-string">&apos;/users/signup&apos;</span>: (request, response) =&gt; {
      mongodb.connect(settings.mongodb.url, <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(error, client)</span> </span>{
        <span class="md-code-keyword">const</span> db = client.db(<span class="md-code-string">&apos;production&apos;</span>);
        <span class="md-code-keyword">const</span> users = db.collection(<span class="md-code-string">&apos;users&apos;</span>);
        <span class="md-code-keyword">const</span> customers = db.collection(<span class="md-code-string">&apos;customers&apos;</span>);

        users.insert({ email: request.body.email, password: request.body.password, profile: request.body.profile }, async <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(error, insertedUser)</span> </span>{
          <span class="md-code-keyword">if</span> (error) {
            <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(error);
          } <span class="md-code-keyword">else</span> {
            <span class="md-code-keyword">const</span> [user] = insertedUser;
            <span class="md-code-keyword">const</span> userId = user._id;
  
            <span class="md-code-keyword">const</span> customerOnStripe = await stripe.customers.create({
              email: request.body.email,
            });

            customers.insert({ userId, stripeCustomerId: customerOnStripe.id }, async <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-params">(error, insertedCustomer)</span> </span>{
              <span class="md-code-keyword">if</span> (error) {
                <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(error);
              } <span class="md-code-keyword">else</span> {
                imaginaryEmailService.send({ to: request.body.email, template: <span class="md-code-string">&apos;welcome&apos;</span> });
                slackLog.success({
                  message: <span class="md-code-string">&apos;New Customer&apos;</span>,
                  metadata: {
                    emailAddress: request.body.email,
                  },
                });

                response.end();
              }
            });
          }
        });
      });
    },  
  },
};
</code></pre> <p>Looking at this code, assuming that all of the parts in use work on their own, it&#x2019;s plausible that this code will work. What&#x2019;s distinct about this code, however, is that it&#x2019;s not terribly organized. It contains a lot of nested calls and not much flow control (i.e., if something fails, the whole house of cards falls).</p> <p>This is where we start to tiptoe up to the &#x201C;works&#x201D; vs. &#x201C;works well&#x201D; chasm. Unfortunately, it&#x2019;s code like this that leads to a lot of wasted time chasing down and fixing bugs. It&#x2019;s not that the code doesn&#x2019;t work, it&#x2019;s that it works <em>unpredictably</em>.</p> <p>You&#x2019;re probably saying &#x201C;well yeah, <em>all</em> code is unpredictable.&#x201D; You&#x2019;re not wrong. But, if we&#x2019;re smart we can significantly reduce the amount of unpredictability, giving us more time to focus on fun stuff&#x2014;not fixing mistakes of the past (either of our own making or someone on our team).</p> <h2 id="introducing-the-action-pattern">Introducing the Action Pattern</h2> <p>First and foremost, it&#x2019;s important to understand that the action pattern is vanilla JavaScript. It&#x2019;s a <em>pattern</em> to follow, not a library or framework to implement. This means that using actions requires a certain level of discipline (the majority of which can be automated via snippets in your IDE).</p> <p>To get started with our conversion, let&#x2019;s look at a skeleton version of an action and then build it up to handle our new user signup.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">/* eslint-disable consistent-return */</span>

<span class="md-code-keyword">const</span> actionMethod = (someOption) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;Do something with someOption&apos;</span>, someOption);
    <span class="md-code-comment">// Perform a single step in your action here.</span>
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[actionName.actionMethod] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> validateOptions = (options) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">if</span> (!options) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options object is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.someOption) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.someOption is required.&apos;</span>);
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[actionName.validateOptions] ${exception.message}`);
  }
};

export <span class="md-code-keyword">default</span> (options) =&gt; {
  <span class="md-code-keyword">try</span> {
    validateOptions(options);
    actionMethod(options.someOption);
    <span class="md-code-comment">// Call action methods in sequence here.</span>
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[actionName] ${exception.message}`);
  }
};
</code></pre> <p>Actions are designed to be read from the bottom up. At the bottom of our file, we export a function known as our handler. This function is responsible for calling to all of the other steps in our action. This helps us to accomplish a few things:</p> <ol> <li>Centralize all of our calls to other code in one place.</li> <li>Share response values from each step with other steps.</li> <li>Clearly delineate the order of steps in our code.</li> <li>Make our code more maintainable and extensible by avoiding nested spaghetti code.</li> </ol> <p>Inside of this function, the very first thing we do is call to <code class="md-code md-code-inline">validateOptions</code> passing in the assumed <code class="md-code md-code-inline">options</code> argument passed to the handler function (or, what we export from our file as our action).</p> <p>With <code class="md-code md-code-inline">validateOptions</code> we start to see a few other sub-patterns of actions appear. Specifically, the name of the <code class="md-code md-code-inline">validateOptions</code> function is called <em>exactly what it does</em>. It&#x2019;s not <code class="md-code md-code-inline">vldOpts</code> or <code class="md-code md-code-inline">validateOps</code> or anything that leaves room for confusion. If I were to drop another developer into this code, and ask them &#x201C;what does that function do?&#x201D; they&#x2019;ll most likely respond sarcastically with &#x201C;uhh, validates the options?&#x201D;</p> <p>The next thing you&#x2019;ll notice is the structure of <code class="md-code md-code-inline">validateOptions</code>. Immediately inside of the function body, a <code class="md-code md-code-inline">try/catch</code> statement is added, with the <code class="md-code md-code-inline">catch</code> portion taking the <code class="md-code md-code-inline">exception</code> and <code class="md-code md-code-inline">throw</code>ing it using the JavaScript <code class="md-code md-code-inline">Error</code> constructor. Notice, too, that <strong>when this error is thrown, we tell ourselves <em>exactly where the error is happening</em></strong> with <code class="md-code md-code-inline">[actionName.validateOptions]</code> followed by the specific error message.</p> <p>In the <code class="md-code md-code-inline">try</code> block, we do what our code says: validate our <code class="md-code md-code-inline">options</code>! The logic here is kept simple on purpose. If our action requires that <code class="md-code md-code-inline">options</code> be passed and requires specific properties to be defined in those <code class="md-code md-code-inline">options</code>, we throw an error if they don&#x2019;t exist. To make sure this clear, if we were to call this action now like this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">actionName();
</code></pre> <p>We&#x2019;d get the following error in response:</p> <pre class="md-code-block"><code class="md-code md-lang-bash">[actionName.validateOptions] options object is required.
</code></pre> <p>This is a <em>serious</em> boon on development. We&#x2019;re telling ourselves exactly what we need up front so we can skip the &#x201C;what did I forget to pass now?&#x201D; roulette.</p> <p>If we move back down to our handler function, we&#x2019;ll see that after our options have been validated with <code class="md-code md-code-inline">validateOptions</code>, our next step is to call <code class="md-code md-code-inline">actionMethod</code>, passing <code class="md-code md-code-inline">options.someOptions</code>.</p> <p>This is where we get into the actual steps or functionality of our action. Here, <code class="md-code md-code-inline">actionMethod</code> takes in <code class="md-code md-code-inline">options.someOption</code>. Notice that because it&#x2019;s the second step called in our handler, it&#x2019;s defined <em>above</em> <code class="md-code md-code-inline">validateOptions</code> (our first step).</p> <p>If we look at <code class="md-code md-code-inline">actionMethod</code> things should&#x2014;purposefully&#x2014;look pretty familiar. Here, we repeat the same pattern: give a clear name for our function, run our code in a <code class="md-code md-code-inline">try/catch</code> block, and if our code fails, <code class="md-code md-code-inline">throw</code> an error telling ourselves that it came from <code class="md-code md-code-inline">[actionName.actionMethod]</code>.</p> <h3 id="refactoring-our-signup">Refactoring our signup</h3> <p>Feeling undewherlmed? Great! That&#x2019;s what we&#x2019;re after. Writing clean code shouldn&#x2019;t be difficult or excessively esoteric. Now, let&#x2019;s start to refactor our signup endpoint into an action. Let&#x2019;s clean up our skeleton, adding some legitimate checks to <code class="md-code md-code-inline">validateOptions</code>:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> actionMethod = (someOption) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;Do something with someOption&apos;</span>, someOption);
    <span class="md-code-comment">// Perform a single step in your action here.</span>
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.actionMethod] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> validateOptions = (options) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">if</span> (!options) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options object is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.body) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.body is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.body.email) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.body.email is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.body.password) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.body.password is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.body.profile) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.body.profile is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.response) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.response is required.&apos;</span>);
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.validateOptions] ${exception.message}`);
  }
};

export <span class="md-code-keyword">default</span> (options) =&gt; {
  <span class="md-code-keyword">try</span> {
    validateOptions(options);
    <span class="md-code-comment">// Call action methods in sequence here.</span>
    options.response.end();
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup] ${exception.message}`);
  }
};
</code></pre> <p>A few things have changed. Notice that instead of <code class="md-code md-code-inline">actionName</code>, we&#x2019;ve now given our action a name: <code class="md-code md-code-inline">signup</code>.</p> <p>Inside of <code class="md-code md-code-inline">validateOptions</code>, we&#x2019;ve set some real expectations, too. Remember that in our original code, we reuse the <code class="md-code md-code-inline">request.body</code> object several times. Here, we think ahead and make the assumption that we&#x2019;ll just pass the <code class="md-code md-code-inline">body</code> part of the request (the only part we utilize). We also make sure to validate that each of the properties <em>of</em> the body are present.</p> <p>Finally, we also want to validate that the <code class="md-code md-code-inline">response</code> object from our endpoint is passed so we can respond to the request within our action.</p> <p>The details of this are mostly arbitrary; the point here is that we&#x2019;re ensuring we have what we need <em>before we put it to use</em>. This helps to eliminate the inevitable &#x201C;did I pass that yet?&#x201D; question as well as subsequent time wasted debugging to figure it out.</p> <h3 id="adding-additional-steps-as-functions">Adding additional steps as functions</h3> <p>Now that we have our handler function set up as well as our <code class="md-code md-code-inline">validateOptions</code>, we can start to port over the core functionality for our action.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">/* eslint-disable consistent-return */</span>

import mongodb from <span class="md-code-string">&apos;/path/to/mongodb&apos;</span>;
import settings from <span class="md-code-string">&apos;/path/to/settings&apos;</span>;

<span class="md-code-keyword">const</span> connectToMongoDB = () =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">new</span> Promise((resolve, reject) =&gt; {
      mongodb.connect(
        settings.mongodb.url,
        (error, client) =&gt; {
          <span class="md-code-keyword">if</span> (error) {
            reject(error);
          } <span class="md-code-keyword">else</span> {
            <span class="md-code-keyword">const</span> db = client.db(<span class="md-code-string">&apos;production&apos;</span>);
            resolve({
              db,
              users: db.collection(<span class="md-code-string">&apos;users&apos;</span>),
              customers: db.collection(<span class="md-code-string">&apos;customers&apos;</span>),
            });
          }
        },
      );
    });
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.connectToMongoDB] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> validateOptions = (options) =&gt; [...];

export <span class="md-code-keyword">default</span> async (options) =&gt; {
  <span class="md-code-keyword">try</span> {
    validateOptions(options);
    <span class="md-code-keyword">const</span> db = await connectToMongoDB();
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup] ${exception.message}`);
  }
};
</code></pre> <p>First, we need to establish a connection to our database. Recall, we need access to the <code class="md-code md-code-inline">users</code> and <code class="md-code md-code-inline">customers</code> collection from MongoDB. Knowing this, we can streamline our code by creating an action method <code class="md-code md-code-inline">connectToMongoDB</code> whose sole job is connecting us to MongoDB, giving us access to the databases we&#x2019;ll need to do our work.</p> <p>To do it, we wrap our call to <code class="md-code md-code-inline">mongodb.connect</code> using the action method pattern. By wrapping this code with a JavaScript <code class="md-code md-code-inline">Promise</code>, we can ensure our connection is complete <em>before</em> we try to use it. This is necessary because we&#x2019;re no longer running our subsequent code accessing the database inside of <code class="md-code md-code-inline">mongodb.connect</code>&apos;s callback. Instead, we <code class="md-code md-code-inline">resolve</code> our <code class="md-code md-code-inline">Promise</code> passing the <code class="md-code md-code-inline">db</code> connection along with the two databases that we&#x2019;ll need: <code class="md-code md-code-inline">users</code> and <code class="md-code md-code-inline">customers</code>.</p> <p>Why is this important? Consider this: our connection to MongoDB could fail. If it does, we not only want to know why, but we want our code to be easily debugged. With nested spaghetti code, this is possible, but adds mental weight.</p> <p>By encapsulating our call&#x2014;and any failures&#x2014;inside of a single function, we eliminate the need to track down errors. This is especially helpful when the errors themselves are unhelpful or ambiguous (R.I.P to souls who get an <code class="md-code md-code-inline">ECONNRESET</code>). The difference between <code class="md-code md-code-inline">ERR ECONNRESET</code> and <code class="md-code md-code-inline">[signup.connectToMongoDB] ERR ECONNRESET</code> is night and day. The error may not be clear, but we&#x2019;ve told ourselves <em>exactly</em> who&#x2019;s responsible.</p> <p>Back in our handler function, we utilize the <code class="md-code md-code-inline">async/await</code> syntax to ensure that we&#x2019;ve received a response from MongoDB <em>before</em> we continue with the rest of our action (i.e., we&#x2019;ve achieved what our callback gave us without opening an Italian restaurant).</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">/* eslint-disable consistent-return */</span>

import mongodb from <span class="md-code-string">&apos;/path/to/mongodb&apos;</span>;
import settings from <span class="md-code-string">&apos;/path/to/settings&apos;</span>;

<span class="md-code-keyword">const</span> createUser = (users, userToCreate) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">new</span> Promise((resolve, reject) =&gt; {
      users.insert(userToCreate, (error, insertedUser) =&gt; {
        <span class="md-code-keyword">if</span> (error) {
          reject(error);
        } <span class="md-code-keyword">else</span> {
          <span class="md-code-keyword">const</span> [user] = insertedUser;
          resolve(user._id);
        }
      });
    });
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.createUser] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> connectToMongoDB = () =&gt; [...];

<span class="md-code-keyword">const</span> validateOptions = (options) =&gt; [...];

export <span class="md-code-keyword">default</span> async (options) =&gt; {
  <span class="md-code-keyword">try</span> {
    validateOptions(options);

    <span class="md-code-keyword">const</span> db = await connectToMongoDB();
    <span class="md-code-keyword">const</span> userId = await createUser(db.users, options.body);
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup] ${exception.message}`);
  }
};
</code></pre> <p>Next up is creating our user. This is where the magic of actions start to show. Down in our handler function, we add our next step <code class="md-code md-code-inline">createUser</code> beneath our first step <code class="md-code md-code-inline">connectToMongoDB</code>. Notice that when we need to reference the value returned by a previous step in future steps, we give it a variable name that represents exactly what&#x2019;s being returned.</p> <p>Here, <code class="md-code md-code-inline">const db</code> suggests we get access to our database in that variable and <code class="md-code md-code-inline">const userId</code> suggests we expect a user&#x2019;s <code class="md-code md-code-inline">_id</code> back from <code class="md-code md-code-inline">createUser</code>. In order to get there, we know that we need to connect to the <code class="md-code md-code-inline">users</code> collection in MongoDB and we need the user information passed in the <code class="md-code md-code-inline">request.body</code> to create that user. To do it, we just pass those values as arguments to <code class="md-code md-code-inline">createUser</code>. Clean and tidy.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> createUser = (users, userToCreate) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">new</span> Promise((resolve, reject) =&gt; {
      users.insert(userToCreate, (error, insertedUser) =&gt; {
        <span class="md-code-keyword">if</span> (error) {
          reject(error);
        } <span class="md-code-keyword">else</span> {
          <span class="md-code-keyword">const</span> [user] = insertedUser;
          resolve(user._id);
        }
      });
    });
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.createUser] ${exception.message}`);
  }
};
</code></pre> <p>Focusing just on our <code class="md-code md-code-inline">createUser</code> definition, we can see that we take in that <code class="md-code md-code-inline">db.users</code> argument as <code class="md-code md-code-inline">users</code> and <code class="md-code md-code-inline">options.body</code> as <code class="md-code md-code-inline">userToCreate</code> (remember, this should be an <code class="md-code md-code-inline">Object</code> with <code class="md-code md-code-inline">email</code>, <code class="md-code md-code-inline">password,</code> and <code class="md-code md-code-inline">profile</code> as properties).</p> <p>Using the same <code class="md-code md-code-inline">Promise</code> approach, we call to <code class="md-code md-code-inline">users.insert</code> and rely on our <code class="md-code md-code-inline">resolve</code> and <code class="md-code md-code-inline">reject</code> to handle the respective error and success states of our call to <code class="md-code md-code-inline">users.insert</code>. If our insert is successful, we get the <code class="md-code md-code-inline">_id</code> of the <code class="md-code md-code-inline">insertedUser</code> and <code class="md-code md-code-inline">resolve()</code> our <code class="md-code md-code-inline">Promise</code> with it.</p> <p>Pay close attention. Because we&#x2019;re calling <code class="md-code md-code-inline">resolve(user._id)</code>, this means that back in our <code class="md-code md-code-inline">handler</code> function, our <code class="md-code md-code-inline">const userId = createUser()</code> is now &#x201C;truthful&#x201D; because once that <code class="md-code md-code-inline">Promise</code> resolves, we&#x2019;ll get the <code class="md-code md-code-inline">userId</code> in return, assigned to that variable. Sweet!</p> <h3 id="completing-our-action">Completing our action</h3> <p>At this point, we&#x2019;re familiar with the core concepts of an action. Once the full conversion is complete, here&#x2019;s what we get:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import mongodb from <span class="md-code-string">&apos;/path/to/mongodb&apos;</span>;
import settings from <span class="md-code-string">&apos;/path/to/settings&apos;</span>;
import stripe from <span class="md-code-string">&apos;/path/to/stripe/api&apos;</span>;
import imaginaryEmailService from <span class="md-code-string">&apos;/path/to/imaginaryEmailService&apos;</span>;
import slackLog from <span class="md-code-string">&apos;/path/to/slackLog&apos;</span>;

<span class="md-code-keyword">const</span> logCustomerOnSlack = (emailAddress) =&gt; {
  <span class="md-code-keyword">try</span> {
    slackLog.success({
      message: <span class="md-code-string">&apos;New Customer&apos;</span>,
      metadata: {
        emailAddress,
      },
    });
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.logCustomerOnSlack] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> sendWelcomeEmail = (to) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">return</span> imaginaryEmailService.send({ to, template: <span class="md-code-string">&apos;welcome&apos;</span> });
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.sendWelcomeEmail] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> createCustomer = (customers, userId, stripeCustomerId) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">new</span> Promise((resolve, reject) =&gt; {
      customers.insert({ userId, stripeCustomerId }, (error, insertedCustomer) =&gt; {
        <span class="md-code-keyword">if</span> (error) {
          reject(error);
        } <span class="md-code-keyword">else</span> {
          <span class="md-code-keyword">const</span> [customer] = insertedCustomer;
          resolve(customer._id);
        }
      });
    });
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.createCustomer] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> createCustomerOnStripe = (email) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">return</span> stripe.customer.create({ email });
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.createCustomerOnStripe] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> createUser = (users, userToCreate) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">new</span> Promise((resolve, reject) =&gt; {
      users.insert(userToCreate, (error, insertedUser) =&gt; {
        <span class="md-code-keyword">if</span> (error) {
          reject(error);
        } <span class="md-code-keyword">else</span> {
          <span class="md-code-keyword">const</span> [user] = insertedUser;
          resolve(user._id);
        }
      });
    });
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.createUser] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> connectToMongoDB = () =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">return</span> <span class="md-code-keyword">new</span> Promise((resolve, reject) =&gt; {
      mongodb.connect(
        settings.mongodb.url,
        (error, client) =&gt; {
          <span class="md-code-keyword">if</span> (error) {
            reject(error);
          } <span class="md-code-keyword">else</span> {
            <span class="md-code-keyword">const</span> db = client.db(<span class="md-code-string">&apos;production&apos;</span>);
            resolve({
              db,
              users: db.collection(<span class="md-code-string">&apos;users&apos;</span>),
              customers: db.collection(<span class="md-code-string">&apos;customers&apos;</span>),
            });
          }
        },
      );
    });
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.connectToMongoDB] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> validateOptions = (options) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">if</span> (!options) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options object is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.body) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.body is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.body.email) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.body.email is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.body.password) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.body.password is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.body.profile) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.body.profile is required.&apos;</span>);
    <span class="md-code-keyword">if</span> (!options.response) <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(<span class="md-code-string">&apos;options.response is required.&apos;</span>);
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.validateOptions] ${exception.message}`);
  }
};

export <span class="md-code-keyword">default</span> async (options) =&gt; {
  <span class="md-code-keyword">try</span> {
    validateOptions(options);

    <span class="md-code-keyword">const</span> db = await connectToMongoDB();
    <span class="md-code-keyword">const</span> userId = await createUser(db.users, options.body);
    <span class="md-code-keyword">const</span> customerOnStripe = await createCustomerOnStripe(options.body.email);

    await createCustomer(db.customers, userId, customerOnStripe.id);
    sendWelcomeEmail(options.body.email);
    logCustomerOnSlack(options.body.email);
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup] ${exception.message}`);
  }
};
</code></pre> <p>A few things to point out. First, all of our additional action methods have been added to our handler, called in sequence.</p> <p>Notice that after we&#x2019;ve created a customer on Stripe (and returned that customer as <code class="md-code md-code-inline">const customerOnStripe</code>), none of the steps after this need a value from the previous steps. In turn, we just call these steps independently without storing their <code class="md-code md-code-inline">return</code> value in a variable.</p> <p>Notice, too, that our <code class="md-code md-code-inline">sendWelcomeEmail</code> and <code class="md-code md-code-inline">logCustomerOnSlack</code> steps remove the usage of an <code class="md-code md-code-inline">await</code> because there&#x2019;s nothing for us to wait on.</p> <p>That&#x2019;s it! At this point, we have a complete action.</p> <h3 id="wait-but-why">Wait, but why?</h3> <p>You&#x2019;re probably wondering &#x201C;didn&#x2019;t we just add a ton of extra code to do the same thing?&#x201D; We did. But something important to consider is how much context and clarity adding that (negligible amount of) extra code gave us.</p> <p>This is the point of actions: giving us a consistent, predictable pattern for organizing complex processes. That&#x2019;s a mouthful, so another way to think about this is reducing maintenance cost. <em>Nobody</em> likes to maintain code. Often, too, when we&#x2019;re tasked with maintaining a &#x201C;legacy&#x201D; codebase, it tends to look more like the code we started with.</p> <p>What this translates to is cost. Cost in time, money, and for the people doing the work: peace of mind. When code is a tangle of pasta, there&#x2019;s a cost to <em>understanding that code</em>. The less structure and consistency, the higher that cost.</p> <p>With actions, we can significantly reduce the amount of thinking that goes into maintaining our code. Not only that, but we also make it incredibly easy to extend our code. For example, if we&#x2019;re asked to add the ability to log the new user in our analytics system, there&#x2019;s little to no thought involved.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">[...]
import analytics from <span class="md-code-string">&apos;/path/to/analytics&apos;</span>;

<span class="md-code-keyword">const</span> trackEventInAnalytics = (userId) =&gt; {
  <span class="md-code-keyword">try</span> {
    <span class="md-code-keyword">return</span> analytics.send(userId);
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup.trackEventInAnalytics] ${exception.message}`);
  }
};

<span class="md-code-keyword">const</span> logCustomerOnSlack = (emailAddress) =&gt; [...];

<span class="md-code-keyword">const</span> sendWelcomeEmail = (to) =&gt; [...];

<span class="md-code-keyword">const</span> createCustomer = (customers, userId, stripeCustomerId) =&gt; [...];

<span class="md-code-keyword">const</span> createCustomerOnStripe = (email) =&gt; [...];

<span class="md-code-keyword">const</span> createUser = (users, userToCreate) =&gt; [...];

<span class="md-code-keyword">const</span> connectToMongoDB = () =&gt; [...];

<span class="md-code-keyword">const</span> validateOptions = (options) =&gt; [...];

export <span class="md-code-keyword">default</span> async (options) =&gt; {
  <span class="md-code-keyword">try</span> {
    validateOptions(options);

    <span class="md-code-keyword">const</span> db = await connectToMongoDB();
    <span class="md-code-keyword">const</span> userId = await createUser(db.users, options.body);
    <span class="md-code-keyword">const</span> customerOnStripe = await createCustomerOnStripe(options.body.email);

    await createCustomer(db.customers, userId, customerOnStripe.id);
    sendWelcomeEmail(options.body.email);
    logCustomerOnSlack(options.body.email);
    trackEventInAnalytics(userId);
  } <span class="md-code-keyword">catch</span> (exception) {
    <span class="md-code-keyword">throw</span> <span class="md-code-keyword">new</span> <span class="md-code-built_in">Error</span>(`[signup] ${exception.message}`);
  }
};
</code></pre> <p>This means that instead of wasting your own time and energy, you can implement features and fix bugs with very little stress. The end result is a happier you and happier stakeholders. Good deal, right?</p> <p>While it&#x2019;s a minor detail, just so it&#x2019;s clear, let&#x2019;s look at how we actually <em>use</em> our action back in our API:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import signup from <span class="md-code-string">&apos;/path/to/signup/action&apos;</span>;

export <span class="md-code-keyword">default</span> {
  v1: {
    <span class="md-code-string">&apos;/users/signup&apos;</span>: (request, response) =&gt; {
      <span class="md-code-keyword">return</span> signup({ body: request.body, response });
    },  
  },
};
</code></pre> <p>This would be an appropriate time for a Bill Cosby &#x201C;puddin&#x2019; face&#x201D; GIF, but, well&#x2026;you know.</p> <h3 id="testing-our-action">Testing our action</h3> <p>The final &#x201C;wow&#x201D; of actions is how easy they are to test. Because the code is already in steps, an action tells us what we need to test. Assuming we&#x2019;ve mocked the functions in use inside of our action (e.g., <code class="md-code md-code-inline">stripe.customers.create</code>) an integration test for our action might look like this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import signup from <span class="md-code-string">&apos;/path/to/signup/action&apos;</span>;
import stripe from <span class="md-code-string">&apos;/path/to/stripe&apos;</span>;
import slackLog from <span class="md-code-string">&apos;/path/to/slackLog&apos;</span>;

<span class="md-code-keyword">const</span> testUser = {
  email: <span class="md-code-string">&apos;test@test.com&apos;</span>,
  password: <span class="md-code-string">&apos;password&apos;</span>,
  profile: { name: <span class="md-code-string">&apos;Test User&apos;</span> },
};

describe(<span class="md-code-string">&apos;signup.js&apos;</span>, () =&gt; {
  beforeEach(() =&gt; {
    stripe.customers.create.mockReset();
    stripe.customers.create.mockImplementation(() =&gt; <span class="md-code-string">&apos;user123&apos;</span>);

    slackLog.success.mockReset();
    slackLog.success.mockImplementation();
  });

  test(<span class="md-code-string">&apos;creates a customer on stripe&apos;</span>, () =&gt; {
    signup({ body: testUser });
    expect(stripe.customers.create).toHaveBeenCalledTimes(<span class="md-code-number">1</span>);
    expect(stripe.customers.create).toHaveBeenCalledWith({ email: testUser.email });
  });

  test(<span class="md-code-string">&apos;logs the new customer on slack&apos;</span>, () =&gt; {
    signup({ body: testUser });
    expect(slackLog.success).toHaveBeenCalledTimes(<span class="md-code-number">1</span>);
    expect(slackLog.success).toHaveBeenCalledWith({
      message: <span class="md-code-string">&apos;New Customer&apos;</span>,
      metadata: {
        emailAddress: testUser.email,
      },
    });
  });
});
</code></pre> <p>Here, each test represents a verification that the step in our action completed as expected. Because we only care that our action performed the steps, our test suite is dirt simple. All we need to do is make a call to our action with some input (in this case, we pass a <code class="md-code md-code-inline">testUser</code> object as the <code class="md-code md-code-inline">options.body</code> value in our action).</p> <p>Next, we verify that our steps complete. Here, we verify that given a user with an email <code class="md-code md-code-inline">test@test.com</code>, our action calls to <code class="md-code md-code-inline">stripe.customers.create</code> passing that same email. Similarly, we test to see of our <code class="md-code md-code-inline">slackLog.success</code> method was called, passing the message we&#x2019;d like to see in our logs.</p> <p>There&#x2019;s ample nuance with testing, of course, but hopefully the point here is clear: we have a very tidy chunk of code that&#x2019;s remarkably easy to test. No confusion. No time wasted &#x201C;figuring it out.&#x201D; The only true cost would be the time mocking out the code called by our action if we hadn&#x2019;t done that already.</p> <h3 id="wrapping-up">Wrapping Up</h3> <p>So there you have it! Actions are a wonderful way to clean up your codebase, make things more predictable, and save yourself a ton of time in the process.</p> <p>Because actions are just a JavaScript pattern, the cost to test them out in your own app is zero. Try it, see if you like it. Most importantly: see if they improve the quality of your code. If you&#x2019;re struggling to write code that performs predictably, give this pattern a try. You won&#x2019;t regret it.</p></div>
