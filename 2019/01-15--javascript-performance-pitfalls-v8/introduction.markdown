In recent years, JavaScript engines have improved on all fronts. The performance of JavaScript has reached a level where it can easily compete with programming languages that have traditionally been considered more appropriate for high-performance computing. This is not only true for V8, the JavaScript engine inside of Chrome and Node.js, but for all major JavaScript engines, including ChakraCore, the engine inside of Edge, JavaScriptCore, the engine inside of Safari, and SpiderMonkey, the engine inside of Firefox.

Not only did the peak performance improve, but engines also managed to deliver more consistent and predictable levels of performance. Given that JavaScript is a *highly dynamic* language, all of this performance is based on choosing the right heuristics in the engine. JavaScript engines use techniques like [speculative optimization](https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8) and [inline caching](https://mathiasbynens.be/notes/shapes-ics) to speed up execution of the *likely path*.

But heuristics can also easily work against you, and it helps to be aware of them. So today I'm gonna share some background on two subtle performance pitfalls in the [V8 JavaScript engine](https://v8.dev). Being aware of these potential pitfalls might help you to resolve issues if you get bitten by these more easily.
