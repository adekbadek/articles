<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/javascript-performance-pitfalls-v8">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/javascript-performance-pitfalls-v8"><div><img src="https://images.ponyfoo.com/uploads/plumber-228010-740c90f82d324e9b810814df5f97af58.jpg" alt="JavaScript Performance Pitfalls in V8"></div></a>

<h1>JavaScript Performance Pitfalls in V8</h1>

<p><kbd>performance</kbd> <kbd>v8</kbd> <kbd>internals</kbd></p>

<blockquote><p>Benedikt shows how V8 compiles your JavaScript programs, and explains a few tricks you can use to avoid draining application performance down the sink.</p>
</blockquote>

<div></div>

<blockquote></blockquote>

<div><p>In recent years, JavaScript engines have improved on all fronts. The performance of JavaScript has reached a level where it can easily compete with programming languages that have traditionally been considered more appropriate for high-performance computing. This is not only true for V8, the JavaScript engine inside of Chrome and Node.js, but for all major JavaScript engines, including ChakraCore, the engine inside of Edge, JavaScriptCore, the engine inside of Safari, and SpiderMonkey, the engine inside of Firefox.</p> <p>Not only did the peak performance improve, but engines also managed to deliver more consistent and predictable levels of performance. Given that JavaScript is a <em>highly dynamic</em> language, all of this performance is based on choosing the right heuristics in the engine. JavaScript engines use techniques like <a href="https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8" target="_blank" rel="noopener noreferrer">speculative optimization</a> and <a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener noreferrer">inline caching</a> to speed up execution of the <em>likely path</em>.</p> <p>But heuristics can also easily work against you, and it helps to be aware of them. So today I&#x2019;m gonna share some background on two subtle performance pitfalls in the <a href="https://v8.dev/" target="_blank" rel="noopener noreferrer">V8 JavaScript engine</a>. Being aware of these potential pitfalls might help you to resolve issues if you get bitten by these more easily.</p></div>

<div><h2 id="optimization-limit">Optimization limit</h2> <p>The compilers built into V8 - both the TurboFan optimizing compiler and the Ignition bytecode generator - are so-called <em>method JITs</em>, meaning the unit of compilation is always a method, aka a function in JavaScript speak. The optimizing compiler is able to include the bodies of other methods when it finds hot call sites and sees potential for further optimizations via doing this, which is commonly referred to as <em>inlining</em>. Contrast this with other runtimes that use so-called <a href="https://en.wikipedia.org/wiki/Tracing_just-in-time_compilation" target="_blank" rel="noopener noreferrer"><em>tracing JITs</em></a> - LuaJIT and PyPy are popular examples here - where the unit of optimization is an arbitrary sequence of consecutive bytecodes that have been executed repeatedly previously.</p> <p>In both method JITs as well as tracing JITs, there&#x2019;s always an upper limit on the size of the input that the optimizer can deal with. For method JITs this limit is naturally defined by the size of the function itself. TurboFan also has such a limit, which is currently 60 KiB of bytecodes (the <a href="https://github.com/v8/v8/blob/e16f4a939e41732bb0103c0847b464501cf760b6/src/runtime-profiler.cc#L38-L39" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">kMaxBytecodeSizeForOpt</code> constant</a> in <a href="https://github.com/v8/v8/blob/e16f4a939e41732bb0103c0847b464501cf760b6/src/runtime-profiler.cc" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">runtime-profiler.cc</code></a>). That means if you have functions whose generated bytecode is bigger than 60 KiB, they will not ever be optimized by TurboFan, even if they are considered hot (i.e. invoked very often).</p> <p>Let&#x2019;s consider an example, using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">eval</code></a> to dynamically generate functions. (We intentionally don&#x2019;t use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">Function</code> constructor</a> here since that doesn&#x2019;t allow us to put a name onto the function that is syntactically recognizable by the JavaScript engine, and that would make the investigations really challenging).</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">generate</span><span class="md-code-params">(n)</span> </span>{
  <span class="md-code-keyword">let</span> s = <span class="md-code-string">&quot;(function add&quot;</span> + n + <span class="md-code-string">&quot;(x) { return 0&quot;</span>;
  <span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>; i &lt; n; ++i) {
    s += <span class="md-code-string">&quot;+x&quot;</span>;
  }
  s += <span class="md-code-string">&quot;; })&quot;</span>;
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">eval</span>(s);
}
</code></pre> <p>This generate function constructs a new JavaScript function object which adds up the parameter passed to it n times. So when you call generate(10) you&#x2019;ll get a function object that looks like this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">add10</span><span class="md-code-params">(x)</span> </span>{
  <span class="md-code-keyword">return</span> <span class="md-code-number">0</span>+x+x+x+x+x+x+x+x+x+x;
}
</code></pre> <p>Now let&#x2019;s take a concrete example of the above and run it in <a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer">Node.js</a>:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// add10.js</span>

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">generate</span><span class="md-code-params">(n)</span> </span>{
  <span class="md-code-keyword">let</span> s = <span class="md-code-string">&quot;(function add&quot;</span> + n + <span class="md-code-string">&quot;(x) { return 0&quot;</span>;
  <span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>; i &lt; n; ++i) {
    s += <span class="md-code-string">&quot;+x&quot;</span>;
  }
  s += <span class="md-code-string">&quot;; })&quot;</span>;
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">eval</span>(s);
}

<span class="md-code-keyword">const</span> add10 = generate(<span class="md-code-number">10</span>);
add10();
</code></pre> <p>Looking at the generated bytecode for the add10 function, using the <code class="md-code md-code-inline">--print-bytecode</code> flag with the <a href="https://nodejs.org/" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">node</code> shell</a>, we see something like this (output is from Node v10.15):</p> <pre class="md-code-block"><code class="md-code">$ node --print-bytecode add10.js
&#x2026;
[generated bytecode for function: add10]
Parameter count 2
Frame size 8
   19 E&gt; 0x279c523204b2 @    0 : a5                StackCheck
   26 S&gt; 0x279c523204b3 @    1 : 0b                LdaZero
         0x279c523204b4 @    2 : 26 fb             Star r0
         0x279c523204b6 @    4 : 25 02             Ldar a0
   34 E&gt; 0x279c523204b8 @    6 : 34 fb 00          Add r0, [0]
         0x279c523204bb @    9 : 26 fb             Star r0
         0x279c523204bd @   11 : 25 02             Ldar a0
   36 E&gt; 0x279c523204bf @   13 : 34 fb 01          Add r0, [1]
         0x279c523204c2 @   16 : 26 fb             Star r0
         0x279c523204c4 @   18 : 25 02             Ldar a0
   38 E&gt; 0x279c523204c6 @   20 : 34 fb 02          Add r0, [2]
         0x279c523204c9 @   23 : 26 fb             Star r0
         0x279c523204cb @   25 : 25 02             Ldar a0
   40 E&gt; 0x279c523204cd @   27 : 34 fb 03          Add r0, [3]
         0x279c523204d0 @   30 : 26 fb             Star r0
         0x279c523204d2 @   32 : 25 02             Ldar a0
   42 E&gt; 0x279c523204d4 @   34 : 34 fb 04          Add r0, [4]
         0x279c523204d7 @   37 : 26 fb             Star r0
         0x279c523204d9 @   39 : 25 02             Ldar a0
   44 E&gt; 0x279c523204db @   41 : 34 fb 05          Add r0, [5]
         0x279c523204de @   44 : 26 fb             Star r0
         0x279c523204e0 @   46 : 25 02             Ldar a0
   46 E&gt; 0x279c523204e2 @   48 : 34 fb 06          Add r0, [6]
         0x279c523204e5 @   51 : 26 fb             Star r0
         0x279c523204e7 @   53 : 25 02             Ldar a0
   48 E&gt; 0x279c523204e9 @   55 : 34 fb 07          Add r0, [7]
         0x279c523204ec @   58 : 26 fb             Star r0
         0x279c523204ee @   60 : 25 02             Ldar a0
   50 E&gt; 0x279c523204f0 @   62 : 34 fb 08          Add r0, [8]
         0x279c523204f3 @   65 : 26 fb             Star r0
         0x279c523204f5 @   67 : 25 02             Ldar a0
   52 E&gt; 0x279c523204f7 @   69 : 34 fb 09          Add r0, [9]
   55 S&gt; 0x279c523204fa @   72 : a9                Return
Constant pool (size = 0)
Handler Table (size = 0)
&#x2026;
</code></pre> <p>Since Node.js runs a lot of its own JavaScript, you might get pages of output here. Search for the phrase <code class="md-code md-code-inline">[generated bytecode for function: add10]</code> where the following bytecode dump contains a sequence of 10 Adds with Star and Ldar bytecodes in between. There&#x2019;s a blog post on <a href="https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775" target="_blank" rel="noopener noreferrer">Understanding V8&#x2019;s Bytecode</a> from my former colleague Franziska Hinkelmann if you&#x2019;re curious to learn more about this topic.</p> <p>Removing the irrelevant parts we see this concrete bytecode output:</p> <pre class="md-code-block"><code class="md-code">  0 : a5                StackCheck
  1 : 0b                LdaZero
  2 : 26 fb             Star r0
  4 : 25 02             Ldar a0
  6 : 34 fb 00          Add r0, [0]
  9 : 26 fb             Star r0
 11 : 25 02             Ldar a0
 13 : 34 fb 01          Add r0, [1]
 16 : 26 fb             Star r0
 18 : 25 02             Ldar a0
 20 : 34 fb 02          Add r0, [2]
 23 : 26 fb             Star r0
 25 : 25 02             Ldar a0
 27 : 34 fb 03          Add r0, [3]
 30 : 26 fb             Star r0
 32 : 25 02             Ldar a0
 34 : 34 fb 04          Add r0, [4]
 37 : 26 fb             Star r0
 39 : 25 02             Ldar a0
 41 : 34 fb 05          Add r0, [5]
 44 : 26 fb             Star r0
 46 : 25 02             Ldar a0
 48 : 34 fb 06          Add r0, [6]
 51 : 26 fb             Star r0
 53 : 25 02             Ldar a0
 55 : 34 fb 07          Add r0, [7]
 58 : 26 fb             Star r0
 60 : 25 02             Ldar a0
 62 : 34 fb 08          Add r0, [8]
 65 : 26 fb             Star r0
 67 : 25 02             Ldar a0
 69 : 34 fb 09          Add r0, [9]
 72 : a9                Return
</code></pre> <p>Looking at the output above, we see that the generated bytecode for <code class="md-code md-code-inline">add10</code> is 73 bytes in size (72 is the offset of the <code class="md-code md-code-inline">Return</code> bytecode and that instruction is 1 byte in size). Given what we learned before about the 60 KiB limit in TurboFan, this function should be easily optimizable by V8. Let&#x2019;s try and see what happens if we put that function in a hot loop.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// add10-optimized.js</span>

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">generate</span><span class="md-code-params">(n)</span> </span>{
  <span class="md-code-keyword">let</span> s = <span class="md-code-string">&quot;(function add&quot;</span> + n + <span class="md-code-string">&quot;(x) { return 0&quot;</span>;
  <span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>; i &lt; n; ++i) {
    s += <span class="md-code-string">&quot;+x&quot;</span>;
  }
  s += <span class="md-code-string">&quot;; })&quot;</span>;
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">eval</span>(s);
}

<span class="md-code-keyword">const</span> add10 = generate(<span class="md-code-number">10</span>);

<span class="md-code-keyword">let</span> result = <span class="md-code-number">0</span>;
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>; i &lt; <span class="md-code-number">5</span> * <span class="md-code-number">1000</span>; ++i) {
  result += add10(i);
}
</code></pre> <p>Running this snippet inside of Node, passing the <code class="md-code md-code-inline">--trace-opt</code> command line flag, we see something similar to the following output:</p> <pre class="md-code-block"><code class="md-code md-lang-xml">$ node --trace-opt add10-optimized.js
[marking 0x32fc83347751 <span class="md-code-tag">&lt;<span class="md-code-title">JSFunction</span> <span class="md-code-attribute">add10</span> (<span class="md-code-attribute">sfi</span> = <span class="md-code-attribute">0x32fcde157b91</span>)&gt;</span> for optimized recompilation, reason: small function, ICs with typeinfo: 10/10 (100%), generic ICs: 0/10 (0%)]
[compiling method 0x32fc83347751 <span class="md-code-tag">&lt;<span class="md-code-title">JSFunction</span> <span class="md-code-attribute">add10</span> (<span class="md-code-attribute">sfi</span> = <span class="md-code-attribute">0x32fcde157b91</span>)&gt;</span> using TurboFan]
[optimizing 0x32fc83347751 <span class="md-code-tag">&lt;<span class="md-code-title">JSFunction</span> <span class="md-code-attribute">add10</span> (<span class="md-code-attribute">sfi</span> = <span class="md-code-attribute">0x32fcde157b91</span>)&gt;</span> - took 0.823, 0.514, 0.016 ms]
[completed optimizing 0x32fc83347751 <span class="md-code-tag">&lt;<span class="md-code-title">JSFunction</span> <span class="md-code-attribute">add10</span> (<span class="md-code-attribute">sfi</span> = <span class="md-code-attribute">0x32fcde157b91</span>)&gt;</span>]
</code></pre> <p>You may see messages about other functions being optimized or marked for optimized recompilation as well, just ignore those. The interesting line is the last line, which says that <code class="md-code md-code-inline">add10</code> was successfully optimized by TurboFan. This matches our expectations. Note that every modern JavaScript engine gives you this behavior.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-comment">// add10000.js</span>

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">generate</span><span class="md-code-params">(n)</span> </span>{
  <span class="md-code-keyword">let</span> s = <span class="md-code-string">&quot;(function add&quot;</span> + n + <span class="md-code-string">&quot;(x) { return 0&quot;</span>;
  <span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>; i &lt; n; ++i) {
    s += <span class="md-code-string">&quot;+x&quot;</span>;
  }
  s += <span class="md-code-string">&quot;; })&quot;</span>;
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">eval</span>(s);
}

<span class="md-code-keyword">const</span> add10000 = generate(<span class="md-code-number">10</span> * <span class="md-code-number">1000</span>);

<span class="md-code-keyword">let</span> result = <span class="md-code-number">0</span>;
<span class="md-code-keyword">for</span> (<span class="md-code-keyword">let</span> i = <span class="md-code-number">0</span>; i &lt; <span class="md-code-number">5</span> * <span class="md-code-number">1000</span>; ++i) {
  result += add10000(i);
}
</code></pre> <p>Let&#x2019;s see what happens if we increase the size of the generated function such that the bytecode for the function exceeds the limit in TurboFan. We choose a rather arbitrary number of 10,000 additions for this example. Running&#x2026;</p> <pre class="md-code-block"><code class="md-code">node --trace-opt add10000.js
</code></pre> <p>Doesn&#x2019;t print anything to the console, meaning that <code class="md-code md-code-inline">add10000</code> is not even considered for optimization by TurboFan (it&#x2019;s a bit unfortunate that V8 doesn&#x2019;t say anything in this case, but just silently continues). In fact TurboFan is not even involved here! Instead, the so-called <code class="md-code md-code-inline">RuntimeProfiler</code> that profiles bytecode execution immediately decides that the function is too big to be considered for optimization and disables optimization of the function (in the <a href="https://github.com/v8/v8/blob/e16f4a939e41732bb0103c0847b464501cf760b6/src/runtime-profiler.cc#L190-L192" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">RuntimeProfiler::ShouldOptimize</code> method</a>).</p> <p>Running <code class="md-code md-code-inline">node</code> again with <code class="md-code md-code-inline">--print-bytecode</code> we see the culprit:</p> <pre class="md-code-block"><code class="md-code">$ node --print-bytecode add10000.js
&#x2026;
[generated bytecode for function: add10000]
Parameter count 2
Frame size 8
   18 E&gt; 0x2e785b7dcf22 @    0 : a0                StackCheck
   24 S&gt; 0x2e785b7dcf23 @    1 : 0b                LdaZero
         0x2e785b7dcf24 @    2 : 26 fb             Star r0
         0x2e785b7dcf26 @    4 : 25 02             Ldar a0
   32 E&gt; 0x2e785b7dcf28 @    6 : 32 fb 00          Add r0, [0]
         0x2e785b7dcf2b @    9 : 26 fb             Star r0
         0x2e785b7dcf2d @   11 : 25 02             Ldar a0
   34 E&gt; 0x2e785b7dcf2f @   13 : 32 fb 01          Add r0, [1]
&#x2026;
20026 E&gt; 0x2e785b7f52aa @ 99208 : 00 32 fb ff 0d 27 Add.Wide r0, [9997]
         0x2e785b7f52b0 @ 99214 : 26 fb             Star r0
         0x2e785b7f52b2 @ 99216 : 25 02             Ldar a0
20028 E&gt; 0x2e785b7f52b4 @ 99218 : 00 32 fb ff 0e 27 Add.Wide r0, [9998]
         0x2e785b7f52ba @ 99224 : 26 fb             Star r0
         0x2e785b7f52bc @ 99226 : 25 02             Ldar a0
20030 E&gt; 0x2e785b7f52be @ 99228 : 00 32 fb ff 0f 27 Add.Wide r0, [9999]
20033 S&gt; 0x2e785b7f52c4 @ 99234 : a4                Return
Constant pool (size = 0)
Handler Table (size = 0)
</code></pre> <p>The function <code class="md-code md-code-inline">add10000</code> generated <strong>99,235 bytes</strong> of bytecode instructions. That certainly exceeds the <strong>60 KiB</strong> limit imposed by the <code class="md-code md-code-inline">RuntimeProfiler</code>.</p> <h3 id="background">Background</h3> <p>There&#x2019;s an ongoing discussion in <a href="https://crbug.com/v8/8598" target="_blank" rel="noopener noreferrer">v8:8598</a> regarding the issue of this optimization limit. In general, there&#x2019;ll always be a limit of some form, since it&#x2019;s all about trade-offs in the engine. In V8&#x2019;s case, the limit allows TurboFan to store various counts (i.e. the number of inputs and outputs of entities in the intermediate representation) as 16-bit integers vs. 32-bit integers. Other engines and languages have similar limits. For example, in Java the 64 KiB method limit is even part of the <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3" target="_blank" rel="noopener noreferrer">JVM bytecode specification</a>.</p> <h3 id="take-away-from-this-section">Take-away from this section</h3> <p>Make sure to split large functions into smaller building blocks. This is generally good advice for maintainability, but also helps the JIT to properly optimize everything that&#x2019;s relevant to your application. Smaller functions also generally play well together with the inlining machinery inside the JIT, and often reduce the cost of compilation and optimization. Imagine you have a bigger function that does 10 different tasks;ven if you only need 1 or 2 of those tasks, you still pay the cost of compiling everything that&#x2019;s in the function (at least compiling to bytecode), plus since inlining heuristics also take into account the size of the inlinee, it&#x2019;s a lot less likely that such a function is inlined at a hot call site.</p> <p>It&#x2019;s worth pointing out that normally you don&#x2019;t run into the 60KiB limit when writing JavaScript, except in some really extreme cases. But tools generating JavaScript programmatically (i.e. parser generators) can hit this limit easily.</p> <h2 id="double-fields">Double fields</h2> <p>The V8 engine uses a technique called <a href="https://en.wikipedia.org/wiki/Tagged_pointer" target="_blank" rel="noopener noreferrer">pointer tagging</a> to encode arbitrary JavaScript values. The trick here to realize that while pointers can be used to address any single byte in memory, this is not needed for JavaScript objects in memory, which usually are aligned to word boundaries (i.e. 4-byte aligned on 32-bit architectures and 8-byte aligned on 64-bit architectures). So the least significant bits in any valid object pointer are zero. V8 uses these bits to encode additional information. In particular it uses the two least significant bits to distinguish between three different kinds of values:</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/1-8b65bb067a394418bd9858de58bad17a.svg"></figure> <p>A <code class="md-code md-code-inline">Smi</code> is a small integer in the 31-bit range, i.e. a value between <code class="md-code md-code-inline">-1,073,741,824</code> and <code class="md-code md-code-inline">1,073,741,823</code><sup><a id="footnote-1" href="#footnote-1-marker" class="md-footnote-ref">1</a></sup>, shifted up by one bit and padded with a <code class="md-code md-code-inline">0</code> in the least significant bit. A <code class="md-code md-code-inline">HeapObject</code> pointer is the address of an object in (managed) memory, with the two least significant bits set to <code class="md-code md-code-inline">01</code>. That means when V8 wants to get to the real address of the object it has to subtract one from the value. There&#x2019;s also the <code class="md-code md-code-inline">WeakHeapObject</code>, which has the least significant bits set to <code class="md-code md-code-inline">11</code>, and is essentially like <code class="md-code md-code-inline">HeapObject</code>, except that the reference is treated weakly by the garbage collector.</p> <p>For the purpose of this article we only care about <code class="md-code md-code-inline">Smi</code> and <code class="md-code md-code-inline">HeapObject</code>. Given that small integers are the most common number values in JavaScript programs, it was considered important to have an efficient value encoding for those. That&#x2019;s why there&#x2019;s the special <code class="md-code md-code-inline">Smi</code> encoding: so that small integers can be stored efficiently, for example inside of objects.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> a = {
  x: <span class="md-code-number">42</span>,
  y: <span class="md-code-string">&quot;Hello&quot;</span>
};
</code></pre> <p>Just consider the object <code class="md-code md-code-inline">a</code> above. It has two properties <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code>, and <code class="md-code md-code-inline">x</code> has a small integer value, whereas <code class="md-code md-code-inline">y</code> has a <code class="md-code md-code-inline">String</code> value. V8 is going to represent that object in memory like this:</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/2-81b41e764823440892cc5e2d335d69c9.svg"></figure> <p>Here <code class="md-code md-code-inline">a</code> is represented as a <code class="md-code md-code-inline">JSObject</code> with a <code class="md-code md-code-inline">Shape</code> that holds the information about the properties of <code class="md-code md-code-inline">a</code>, and the actual values of the properties are in the instance <code class="md-code md-code-inline">a</code> (you can read more about shapes in our previous articles <a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener noreferrer">JavaScript engine fundamentals: Shapes and Inline Caches</a> and <a href="https://mathiasbynens.be/notes/prototypes" target="_blank" rel="noopener noreferrer">JavaScript engine fundamentals: optimizing prototypes</a>). Due to the value encoding mentioned above, the small integer <code class="md-code md-code-inline">42</code> can be stored efficiently inside of the <code class="md-code md-code-inline">JSObject</code> whereas the <code class="md-code md-code-inline">String</code> value has to be represented as a separate entity in memory and pointed to by a <code class="md-code md-code-inline">HeapObject</code> pointer.</p> <p>Now for <code class="md-code md-code-inline">String</code>s that seems kind of obvious and makes sense to have them allocated as separate entities<sup><a id="footnote-2" href="#footnote-2-marker" class="md-footnote-ref">2</a></sup>, but what about other number values for example? In JavaScript numbers are <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format" target="_blank" rel="noopener noreferrer">64-bit double precision floating point values</a> so they can encode a lot of values outside the 31-bit integer range. In the basic pointer tagging scheme used in V8, all numbers outside this range have to represented as separately allocated <code class="md-code md-code-inline">HeapObject</code> entities.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> b = {
  x: <span class="md-code-number">2</span> ** <span class="md-code-number">32</span>,
  y: <span class="md-code-number">1.5</span>
};
</code></pre> <p>In the example of <code class="md-code md-code-inline">b</code> above, we assign <code class="md-code md-code-inline">x</code> an integer value 4,294,967,296, which is outside the 31-bit integer range, and <code class="md-code md-code-inline">y</code> is assigned a number that is not even an integer at all. Neither of these values cannot use the efficient <code class="md-code md-code-inline">Smi</code> encoding, and thus need separate heap-allocated entities, so-called <code class="md-code md-code-inline">HeapNumber</code>s in V8 speak:</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/3-7f6a7c8cb77042f0a5259b7d6f5ce065.svg"></figure> <p>As you can imagine this would be quite costly when you think of applications that operate on data structures that mostly consist of numeric values outside the 31-bit signed integer range, i.e. points, vectors, etc, and often update the values of these properties. In such cases every update to these properties would have to allocate a new <code class="md-code md-code-inline">HeapNumber</code> entity, since these entities are by their nature immutable (since they are passed around and thus can be referenced from many different places).</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> c = {x: <span class="md-code-number">1.1</span>};
c.x = <span class="md-code-number">1.2</span>;
c.x = <span class="md-code-number">1.3</span>;
</code></pre> <p>Running this simple snippet results in the creation of three <code class="md-code md-code-inline">HeapNumber</code> objects, one for each of the different numbers <code class="md-code md-code-inline">1.1</code>, <code class="md-code md-code-inline">1.2</code> and <code class="md-code md-code-inline">1.3</code>.</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/4-ae3d54be43c34f698f379903b82574de.svg"></figure> <p>Always having to allocate new <code class="md-code md-code-inline">HeapNumber</code>s can be quite costly specifically for numeric applications, as it causes a lot of traffic on the garbage collector and may lead to bad cache locality.</p> <p>To mitigate this problem for applications that operate on lots of objects with numeric properties, V8 has a concept called <em>field representation tracking</em>, which tracks for each field in an object what the <em>representation</em> of the values were so far. Specifically V8 tracks whether a field (as described by a concrete shape) has always stored numbers so far, where we distinguish between states <code class="md-code md-code-inline">Smi</code> and <code class="md-code md-code-inline">Double</code> (the former meaning that only values in the small integer range were seen, the latter means that also other number values outside that range occurred).</p> <p>Fields with <code class="md-code md-code-inline">Smi</code> representation are already stored efficiently as described above, but the optimizing compiler TurboFan can use the field representation information to generate more efficient code (i.e. it doesn&#x2019;t need to check whether the field contains an integer since that&#x2019;s known from the representation on the shape). For <code class="md-code md-code-inline">Double</code> fields a new <code class="md-code md-code-inline">MutableHeapNumber</code> entity was introduced that looks like a <code class="md-code md-code-inline">HeapNumber</code>, but is tied to the instance and can be updated in-place.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> c = {x: <span class="md-code-number">1.1</span>};
c.x = <span class="md-code-number">1.2</span>;
c.x = <span class="md-code-number">1.3</span>;
</code></pre> <p>Looking at this example with the update again, we see that only a single storage for the double values need to be allocated and it&#x2019;s just updated to the most recent value in-place:</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/5-5267ccde251b4efb98739191cf42becd.svg"></figure> <p>Notice how the <em>Property information</em> now tags the property <code class="md-code md-code-inline">&apos;x&apos;</code> as a <code class="md-code md-code-inline">Double</code> field.</p> <p>This optimization is done by V8 under the hood, as a developer you don&#x2019;t even notice that it&#x2019;s going on. And even better, on 64-bit architectures V8 can store the double values inline into the instance itself, using a technique called <em>double field unboxing</em>. I&#x2019;m not going to describe that here, since the details of that are quite complex. Take-away so far should be that this goes on automatically and usually does the right thing for you.</p> <p>But as with any heuristic, there are trade-offs. You might already ask yourself how that work with the dynamic nature of JavaScript? Specifically since a field can hold any arbitrary value at any given point in time. Like what if you decide to store a string into <code class="md-code md-code-inline">c.x</code> at some point?</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">c.x = <span class="md-code-string">&quot;Hello&quot;</span>;
</code></pre> <p>This is perfectly valid in JavaScript, and V8 handles this by having a lattice of field representations like this:</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/6-8c0e7f9ab9234027a0de90890a49bf86.svg"></figure> <p>For each field V8 will choose the best possible representation given the value that&#x2019;s being stored, and it will progress through the lattice as necessary. Like in the case of storing a string into a field that currently has a <code class="md-code md-code-inline">Double</code> representation tag, it&#x2019;ll progress the field to <code class="md-code md-code-inline">Tagged</code> representation, which essentially says <em>anything</em>. Ideally fields should have one of <code class="md-code md-code-inline">Smi</code>, <code class="md-code md-code-inline">Double</code> or <code class="md-code md-code-inline">HeapObject</code> representation tags (highlighted in orange above), i.e. you should not mix numbers and other values, for best performance in most cases. You may already know about <a href="https://v8.dev/blog/elements-kinds" target="_blank" rel="noopener noreferrer">the concept of elements kinds in V8</a>, which is very similar to the field representation mechanism. Elements kinds are concerned with array-indexed properties, whereas field representations are used for non-array indexed properties.</p> <h3 id="mixed-number-and-non-number-fields">Mixed number and non-number fields</h3> <p>When you store both number and non-number values into a field, its field representation is going to be <code class="md-code md-code-inline">Tagged</code> for sure, since that&#x2019;s the only valid representation for fields that hold both number and non-number values. If this is really what you intended to do, good. But if you intended to operate on number values really, then mixing in non-number values, including <code class="md-code md-code-inline">undefined</code> or <code class="md-code md-code-inline">null</code> primitives is a bad idea. Performance-wise the JavaScript engine can skip a bunch of checks if it knows that a field has <code class="md-code md-code-inline">Smi</code> or <code class="md-code md-code-inline">Double</code> representation. Consider this simple example</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">distance</span><span class="md-code-params">(p1, p2)</span> </span>{
  <span class="md-code-keyword">const</span> dx = p1.x - p2.x;
  <span class="md-code-keyword">const</span> dy = p1.y - p2.y;
  <span class="md-code-keyword">return</span> <span class="md-code-built_in">Math</span>.sqrt(dx * dx + dy * dy);
}
</code></pre> <p>which computes the distance between two points <code class="md-code md-code-inline">p1</code> and <code class="md-code md-code-inline">p2</code>. Without any additional information about the representation of the fields <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code>, the engine would need to check that the results of the four property accesses <code class="md-code md-code-inline">p1.x</code>, <code class="md-code md-code-inline">p2.x</code>, <code class="md-code md-code-inline">p1.y</code>, and <code class="md-code md-code-inline">p2.y</code> all yields numbers (and handle the case where they are not).</p> <p>Specifically don&#x2019;t ever pre-initialize number fields with <code class="md-code md-code-inline">undefined</code> or <code class="md-code md-code-inline">null</code>, unless there&#x2019;s a good reason why this would be necessary for your application. That being said, don&#x2019;t do something like this</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Point {
  constructor() {
    <span class="md-code-keyword">this</span>.x = <span class="md-code-literal">null</span>;
    <span class="md-code-keyword">this</span>.y = <span class="md-code-literal">null</span>;
  }

  setX(x) { <span class="md-code-keyword">this</span>.x = x; }
  setY(y) { <span class="md-code-keyword">this</span>.y = y; }
}
</code></pre> <p>i.e. use <code class="md-code md-code-inline">null</code> as a sentinel value for number fields. Prefer actual number values, i.e. maybe just <code class="md-code md-code-inline">0</code> (if you plan on using small integers) or <code class="md-code md-code-inline">0.1</code> or even <code class="md-code md-code-inline">NaN</code> (if you plan on using floats).</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Point {
  constructor() {
    <span class="md-code-keyword">this</span>.x = <span class="md-code-number">0.1</span>;
    <span class="md-code-keyword">this</span>.y = <span class="md-code-number">0.1</span>;
  }

  setX(x) { <span class="md-code-keyword">this</span>.x = x; }
  setY(y) { <span class="md-code-keyword">this</span>.y = y; }
}
</code></pre> <h3 id="smi-to-double-migrations"><code class="md-code md-code-inline">Smi</code> to <code class="md-code md-code-inline">Double</code> migrations</h3> <p>Even if you pay attention to what was said above, there&#x2019;s still another subtle problem that you might run into with number fields. For example the <a href="https://github.com/facebook/react" target="_blank" rel="noopener noreferrer">React</a> team got bitten by this <a href="https://github.com/facebook/react/issues/14365" target="_blank" rel="noopener noreferrer">recently</a>. The subtle issue here, without going into too much detail, is that <code class="md-code md-code-inline">Smi</code> and <code class="md-code md-code-inline">Double</code> field representation aren&#x2019;t compatible: The former requires the number to be encoded as part of the value in the field, the latter requires the number to be stored in a dedicated <code class="md-code md-code-inline">MutableHeapNumber</code> entity. So going from <code class="md-code md-code-inline">Smi</code> to <code class="md-code md-code-inline">Double</code> involves a process called <em>instance migration</em>, where instances that used to have the value stored as a <code class="md-code md-code-inline">Smi</code> need to be migrated to have the field value stored in a <code class="md-code md-code-inline">MutableHeapNumber</code> instead.</p> <p>This process involves creating entirely new shapes for the instances, and lazily migrating instances from the old shape to the new shape as the engine hits the instances. (It would be too expensive to stop the world and find all the instances in managed memory at the time when the migration is kicked off). Since shapes are organized in trees (as explained in <a href="https://mathiasbynens.be/notes/shapes-ics" target="_blank" rel="noopener noreferrer">JavaScript engine fundamentals: Shapes and Inline Caches</a>), this might involve the creation of new shape subtrees. Consider this example of two objects <code class="md-code md-code-inline">o1</code> and <code class="md-code md-code-inline">o2</code> with <code class="md-code md-code-inline">Smi</code> fields <code class="md-code md-code-inline">x</code> and <code class="md-code md-code-inline">y</code>:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> o1 = {};
o1.x = <span class="md-code-number">3</span>;
o1.y = <span class="md-code-number">4</span>;

<span class="md-code-keyword">const</span> o2 = {};
o2.x = <span class="md-code-number">5</span>;
o2.y = <span class="md-code-number">6</span>;
</code></pre> <p>This creates appropriate shapes and transitions between these shapes as outlined below:</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/7-86e5543b40894a178742aaa94ca0d7a2.svg"></figure> <p>Now imagine we change the value of <code class="md-code md-code-inline">o2.x</code> to value <code class="md-code md-code-inline">5.5</code>, which cannot be represented as a <code class="md-code md-code-inline">Smi</code> like this:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">o2.x = <span class="md-code-number">5.5</span>;
</code></pre> <p>Now V8 has to create a whole new subtree starting from the shape that introduced the property <code class="md-code md-code-inline">x</code>, and have <code class="md-code md-code-inline">o2</code> use the new shape. The instance <code class="md-code md-code-inline">o1</code> still points to the previous shape, which is now marked as deprecated.</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/8-b321185c82e8443a919ebc598a320f69.svg"></figure> <p>As the diagram shows, the old shape subtree is essentially disconnected from the root shape, and instead a new shape subtree is put in place. All the shapes in the old subtree are marked as deprecated, and will eventually be garbage-collected once no more instances use them. In the meantime however there&#x2019;s additional overhead essentially keeping two separate trees of metadata alive.</p> <p>The next time <code class="md-code md-code-inline">o1</code> is seen by any IC (inline cache), it automatically migrates the instance away from the deprecated shape to its so-called <em>migration target</em>, which is the corresponding shape in the new subtree. For example, if you now perform a property access like <code class="md-code md-code-inline">o1.y</code> it&#x2019;ll automatically do this self-healing. You don&#x2019;t even need to store to it; loading any property from it is sufficient. And this also forces <code class="md-code md-code-inline">o1.x</code> into a <code class="md-code md-code-inline">Double</code> field representation, so that afterwards <code class="md-code md-code-inline">o1</code> and <code class="md-code md-code-inline">o2</code> use the same shape again:</p> <figure><img alt="" class="" src="https://images.ponyfoo.com/uploads/9-558e060a3d2f4bb19c74b871d2315911.svg"></figure> <p>Now imagine what happens when this has to be done for thousands of objects with plenty of properties on them, which is kinda what happened in <a href="https://github.com/facebook/react/issues/14365" target="_blank" rel="noopener noreferrer">facebook/react#14365</a>, except that in their case, it was some bad interaction with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions" target="_blank" rel="noopener noreferrer"><code class="md-code md-code-inline">Object.preventExtensions()</code></a> on top, where a bug in V8 causes it to miss the proper <em>migration target</em> somehow, and so V8 ended up allocating a new unique shape for each and every <code class="md-code md-code-inline">FiberNode</code> instance in this application. The relevant issue <a href="https://crbug.com/v8/8538" target="_blank" rel="noopener noreferrer">v8:8538</a> is still under investigation.</p> <p>The actionable advice for you here is to make sure that whenever you&#x2019;re going to use a field to hold arbitrary number values (including values outside the small integer range), initialize this field with a non-small integer number. That way, you get the correct shapes from the beginning, and you avoid the migration cost (and troubles). One easy way to accomplish this is to store <code class="md-code md-code-inline">NaN</code> initially<sup><a id="footnote-3" href="#footnote-3-marker" class="md-footnote-ref">3</a></sup>, which was also the fix for the React issue:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">class</span> Point {
  constructor(x, y) {
    <span class="md-code-keyword">this</span>.x = <span class="md-code-literal">NaN</span>; <span class="md-code-keyword">this</span>.x = x;
    <span class="md-code-keyword">this</span>.y = <span class="md-code-literal">NaN</span>; <span class="md-code-keyword">this</span>.y = y;
  }
}
</code></pre> <p>But also like with all performance advice: Don&#x2019;t do this blindly everywhere. A lot of your code is probably fine and unaffected performance-wise, even if objects undergo migrations sometimes.</p> <h3 id="take-away-from-this-section">Take-away from this section</h3> <p>Try to avoid mixing field values of different types, i.e. don&#x2019;t mix numbers, strings, objects, other primitives, unless that&#x2019;s what you intended to do. Specifically don&#x2019;t pre-initialize number fields to <code class="md-code md-code-inline">null</code> or <code class="md-code md-code-inline">undefined</code>, but choose sensible default numbers (use <code class="md-code md-code-inline">NaN</code> if in doubt). And try to initialize double fields (aka fields that are supposed to hold number values outside the small integer range) with double values outside the small integer range up-front, i.e. if in doubt put a <code class="md-code md-code-inline">NaN</code> there first, and then store the actual initial value.</p> <h2 id="conclusion">Conclusion</h2> <p>You should trust that the JavaScript engines usually do the right thing for you automatically. But as with everything, it&#x2019;s good to be aware of some of the details, so in case you bump into problems, you&#x2019;ll find your way around it, and sometimes giving the JavaScript engine an additional hint can be beneficial if the heuristics would otherwise fail badly.</p> <div class="md-footnotes"> <div id="footnote-1-marker" class="md-footnote"><a href="#footnote-1" class="md-footnote-anchor">1</a><div><p>At the time of this writing, <code class="md-code md-code-inline">Smi</code>s on 64-bit architectures are integers in the 32-bit range, but this is probably going to change to use 31-bit ranged integers everywhere in the near future.</p> </div></div> <div id="footnote-2-marker" class="md-footnote"><a href="#footnote-2" class="md-footnote-anchor">2</a><div><p>Although there are also JavaScript VMs that manage to store short strings encoded into the value itself, for example the <a href="https://github.com/cesanta/v7" target="_blank" rel="noopener noreferrer">V7 Embedded JavaScript engine</a> does that.</p> </div></div> <div id="footnote-3-marker" class="md-footnote"><a href="#footnote-3" class="md-footnote-anchor">3</a><div><p>Choice of <code class="md-code md-code-inline">NaN</code> is completely arbitrary here, it&#x2019;s just the way I&#x2019;d do it, as it signals to my future self reading this code that I didn&#x2019;t accidentally overwrite the value immediately, but did this on purpose. You can use any non-small integer number here, i.e. <code class="md-code md-code-inline">0.1</code>, <code class="md-code md-code-inline">Number.MAX_VALUE</code> or even <code class="md-code md-code-inline">-0</code> would all work here.</p> </div></div> </div></div>
