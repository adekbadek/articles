<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/setting-up-elasticsearch-for-a-blog">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/setting-up-elasticsearch-for-a-blog"><div><img src="https://i.imgur.com/ytDmMbK.jpg" alt="Setting Up Elasticsearch for a Blog"></div></a>

<h1>Setting Up Elasticsearch for a Blog</h1>

<p><kbd>ponyfoo</kbd> <kbd>elastic</kbd> <kbd>elasticsearch</kbd></p>

<blockquote><p>I&#x2019;ve been experimenting with <code>elasticsearch</code> <em>&#x2013; and working at the company behind it for a while &#x2013;</em> so it only made sense to incorporate it as Pony Foo&#x2019;s search provider.</p>
</blockquote>

<div><p>I&#x2019;ve been experimenting with <code class="md-code md-code-inline">elasticsearch</code> &#x2013; and working at the company behind it for a while &#x2013; so it only made sense to incorporate it as Pony Foo&#x2019;s search provider.</p></div>

<blockquote></blockquote>

<div><p>This article describes in detail the steps I took in setting up Elasticsearch as the search provider for Pony Foo. I start by explaining what Elasticsearch is, how you can set it up to make useful searches through the Node.js API client, and how to deploy the solution onto a Debian or Ubuntu environment.</p> <p>A while back I started working at Elastic &#x2013; the <a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener noreferrer" aria-label="Elasticsearch product overview">company behind Elasticsearch</a>, a search engine &amp; realtime analytics service powered by Lucene indexes. It&#x2019;s an <strong>extremely exciting open-source company</strong> and I&#x2019;m super happy here <em>&#x2013; and we&#x2019;re hiring, drop me a note!</em> &#x1F609;</p> <figure class="twitter-tweet-figure figure-has-loaded"><blockquote class="twitter-tweet"><p>&#x1F389; Thrilled to announce I&apos;ve started working at <a href="https://twitter.com/elastic">@elastic</a>!<br>&#x26F9; Working on Kibana (ES graphs)<br>&#x1F44C; Great fun/team! Hiring!<br>&#x1F3A2; <a href="https://t.co/8u8B4o5IFf">https://t.co/8u8B4o5IFf</a></p>&#x2014; Nicol&#xE1;s Bevacqua (@nzgb) <a href="https://twitter.com/nzgb/status/714803063958077441">March 29, 2016</a></blockquote> </figure><p>Possible use cases for Elasticsearch range from indexing millions of HTTP log entries, analyzing public traffic incidents in real-time, streaming tweets, all the way to tracking and predicting earthquakes and back to providing search for a lowly blog like Pony Foo.</p> <p>We also build <a href="https://github.com/elastic/kibana" target="_blank" rel="noopener noreferrer" aria-label="elastic/kibana on GitHub">Kibana</a>, a dashboard that sits in front of Elasticsearch and lets you perform and graph the most complex queries you can possibly imagine. Many use Kibana across those cool service status flat screens in hip offices across San Francisco.</p> <figure><a href="https://github.com/elastic/kibana" target="_blank" rel="noopener noreferrer" aria-label="elastic/kibana on GitHub"><img alt="Image of Kibana on flat screens across an office." class="" src="https://i.imgur.com/6lNsZrT.jpg"></a></figure> <p>But enough about me and the cool things you can do with Elastic&#x2019;s products. Let&#x2019;s start by talking about Elasticsearch in more meaningful, technical terms.</p></div>

<div><h1 id="what-is-elasticsearch-even">What is Elasticsearch, even? &#x1F50E;</h1> <p>Elasticsearch is a REST HTTP service that wraps around <a href="https://lucene.apache.org/" target="_blank" rel="noopener noreferrer" aria-label="&#x201C;Apache Lucene and Solr set the standard for search and indexing performance&#x201D;">Apache Lucene</a>, a Java-based indexing and search technology that also features spellchecking, hit highlighting and advanced analysis/tokenization capabilities. On top of what Lucene already provides, Elasticsearch adds an HTTP interface, meaning you don&#x2019;t need to build your application using Java anymore; and is distributed by default, meaning you won&#x2019;t have any trouble scaling your operations to thousands of queries per second.</p> <p>Elasticsearch is great for setting up blog search because you could basically dump all your content into an index and have them deal with user&#x2019;s queries, with very little effort or configuration.</p> <p>Here&#x2019;s how I did it.</p> <h1 id="initial-setup">Initial Setup</h1> <p>I&#x2019;m on a Mac, so <em>&#x2013; for development purposes &#x2013;</em> I just installed <code class="md-code md-code-inline">elasticsearch</code> using <a href="http://brew.sh/" target="_blank" rel="noopener noreferrer" aria-label="&#x201C;The missing package manager for OS X&#x201D;">Homebrew</a>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">brew install elasticsearch
</code></pre> <p>If you&#x2019;re not on a Mac, just go to the download page and <a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener noreferrer" aria-label="Download Elasticsearch">get the latest version</a>, unzip it, run it in a shell, and you&#x2019;re good to go.</p> <figure><a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener noreferrer" aria-label="Download Elasticsearch"><img alt="Installation steps for Elasticsearch" class="" src="https://i.imgur.com/5ndK5vx.png"></a></figure> <p>Once you have the <code class="md-code md-code-inline">elasticsearch</code> executable, you can run it on your terminal. Make sure to leave the process running while you&#x2019;re working with it.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">elasticsearch
</code></pre> <p>Querying the index is a matter of using <code class="md-code md-code-inline">curl</code>, which is a great diagnostics tool to have a handle on; a web browser, by querying <code class="md-code md-code-inline">http://localhost:9200</code> <em>(<code class="md-code md-code-inline">9200</code> is the port Elasticsearch listens at by default)</em>; the <a href="https://chrome.google.com/webstore/detail/sense-beta/lhjgkmllcaadmopgmanpapmpjgmfcfig?hl=en" target="_blank" rel="noopener noreferrer" aria-label="Sense on the Chrome Web Extension">Sense</a> Chrome extension, which provides a simple interface into the Elasticsearch REST service, or the <a href="https://www.elastic.co/guide/en/kibana/5.0/console-kibana.html" target="_blank" rel="noopener noreferrer" aria-label="The Console plugin provides a UI to interact with the REST API of Elasticsearch">Console plugin for Kibana</a>, which is similar to Sense.</p> <p>There are client libraries that consume the HTTP REST API available to several different languages. In our case, we&#x2019;ll use the Node.js client: <a href="https://www.npmjs.com/package/elasticsearch" target="_blank" rel="noopener noreferrer" aria-label="elasticsearch on npm"><code class="md-code md-code-inline">elasticsearch</code></a>.</p> <pre class="md-code-block"><code class="md-code md-lang-bash">npm install --save elasticsearch
</code></pre> <p>The <code class="md-code md-code-inline">elasticsearch</code> API client is quite pleasant to work with, they provide both <code class="md-code md-code-inline">Promise</code>-based and callback-based API through the same methods. First off, we&#x2019;ll create a client. This will be used to talk to the REST service for our Elasticsearch instance.</p> <h1 id="creating-an-elasticsearch-index">Creating an Elasticsearch Index</h1> <p>We&#x2019;ll start by importing the <code class="md-code md-code-inline">elasticsearch</code> package and instantiating a REST client configured to print all logging statements.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import elasticsearch from <span class="md-code-string">&apos;elasticsearch&apos;</span>;
<span class="md-code-keyword">const</span> client = <span class="md-code-keyword">new</span> elasticsearch.Client({
  host: <span class="md-code-string">&apos;http://localhost:9200&apos;</span>,
  log: <span class="md-code-string">&apos;debug&apos;</span>
});
</code></pre> <p>Now that we have a <code class="md-code md-code-inline">client</code> we can start interacting with our Elasticsearch instance. We&#x2019;ll need an index where we can store our data. You can think of <a href="https://www.elastic.co/blog/what-is-an-elasticsearch-index" target="_blank" rel="noopener noreferrer" aria-label="What is an Elasticsearch Index?">an Elasticsearch index</a> as the rough equivalent of a database instance. A huge difference, though, is that <strong>you can very easily query multiple Elasticsearch indices</strong> at once <em>&#x2013; something that&#x2019;s not trivial with other database systems.</em></p> <p>I&#x2019;ll create an index named <code class="md-code md-code-inline">&apos;ponyfoo&apos;</code>. Since <code class="md-code md-code-inline">client.indices.create</code> returns a <code class="md-code md-code-inline">Promise</code>, we can <code class="md-code md-code-inline">await</code> on it for our code to stay easy to follow. If you need to brush up on <code class="md-code md-code-inline">async</code> / <code class="md-code md-code-inline">await</code> you may want to read <a href="https://ponyfoo.com/articles/understanding-javascript-async-await" aria-label="Understanding JavaScript&#x2019;s async await on Pony Foo">&#x201C;Understanding JavaScript&#x2019;s async await&#x201D;</a> and the <a href="https://ponyfoo.com/articles/es6-promises-in-depth" aria-label="ES6 Promises in Depth on Pony Foo">article on Promises</a> as well.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">await client.indices.create({ index: <span class="md-code-string">&apos;ponyfoo&apos;</span> });
</code></pre> <p>That&#x2019;s all the setup that is <strong>required</strong>.</p> <h1 id="creating-an-elasticsearch-mapping">Creating an Elasticsearch Mapping</h1> <p>In addition to creating an index, you can <em>optionally</em> create <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/mapping.html" target="_blank" rel="noopener noreferrer" aria-label="Mapping is the process of defining how a document, and the fields it contains, are stored and indexed">an explicit type mapping</a>. Type mappings aid Elasticsearch&#x2019;s querying capabilities for your documents &#x2013; avoiding issues when you are storing dates using their timestamps, <a href="https://www.elastic.co/blog/found-elasticsearch-mapping-introduction" target="_blank" rel="noopener noreferrer" aria-label="An Introduction to Elasticsearch Mapping">among other things</a>.</p> <p>If you don&#x2019;t create an explicit mapping for a type, Elasticsearch will <strong>infer field types based on inserted documents</strong> and create a dynamic mapping.</p> <blockquote> <p><em>A timestamp is often represented in JSON as a <code class="md-code md-code-inline">long</code>, but Elasticsearch will be unable to detect the field as a <code class="md-code md-code-inline">date</code> field, preventing date filters and facets such as the date histogram facet from working properly.</em><br> <em>&#x2014; <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/mapping.html" target="_blank" rel="noopener noreferrer" aria-label="Mapping is the process of defining how a document, and the fields it contains, are stored and indexed">Elasticsearch Documentation</a></em></p> </blockquote> <p>Let&#x2019;s create a mapping for the type <code class="md-code md-code-inline">&apos;article&apos;</code>, which is the document type we&#x2019;ll use when storing blog articles in our Elasticsearch index. Note how even though the <code class="md-code md-code-inline">tags</code> property will be stored as an array, Elasticsearch takes care of that internally and we only need to specify that each tag is of type string. The <code class="md-code md-code-inline">created</code> property will be a <code class="md-code md-code-inline">date</code>, as hinted by the mapping, and everything else is stored as strings.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">await client.indices.putMapping({
  index: <span class="md-code-string">&apos;ponyfoo&apos;</span>,
  type: <span class="md-code-string">&apos;article&apos;</span>,
  body: {
    properties: {
      created: { type: <span class="md-code-string">&apos;date&apos;</span> },
      title: { type: <span class="md-code-string">&apos;string&apos;</span> },
      slug: { type: <span class="md-code-string">&apos;string&apos;</span> },
      teaser: { type: <span class="md-code-string">&apos;string&apos;</span> },
      introduction: { type: <span class="md-code-string">&apos;string&apos;</span> },
      body: { type: <span class="md-code-string">&apos;string&apos;</span> },
      tags: { type: <span class="md-code-string">&apos;string&apos;</span> }
    }
  }
});
</code></pre> <p>The remainder of our initial setup involves two steps &#x2013; both of them involving keeping the Elasticsearch index up to date, so that querying it yields meaningful results.</p> <ul> <li>Importing all of the current articles into our Elasticsearch index</li> <li>Updating the Elasticsearch index whenever an article is updated or a new article is created</li> </ul> <h1 id="keeping-elasticsearch-up-to-date">Keeping Elasticsearch Up-to-date</h1> <p>These steps vary slightly depending on the storage engine you&#x2019;re using for blog articles. For Pony Foo, I&#x2019;m using MongoDB and the <code class="md-code md-code-inline">mongoose</code> driver. The following piece of code will trigger a post-save hook whenever an article is saved <em>&#x2013; regardless of whether we&#x2019;re dealing with an insert or an update.</em></p> <pre class="md-code-block"><code class="md-code md-lang-javascript">mongoose.model(<span class="md-code-string">&apos;Article&apos;</span>).schema.post(<span class="md-code-string">&apos;save&apos;</span>, <mark class="md-mark md-code-mark">updateIndex</mark>);
</code></pre> <p>The <code class="md-code md-code-inline">updateIndex</code> method is largely independent of the storage engine: our goal is to update the Elasticsearch index with the updated document. We&#x2019;ll be using the <code class="md-code md-code-inline">client.update</code> method for an article of <code class="md-code md-code-inline">id</code> equal to the <code class="md-code md-code-inline">_id</code> we had in our MongoDB database, although that&#x2019;s entirely up to you &#x2013; I chose to reuse the MongoDB, as I found it most convenient. The provided <code class="md-code md-code-inline">doc</code> should match the type mapping we created earlier, and as you can see I&#x2019;m just forwarding part of my MongoDB document to the Elasticsearch index.</p> <p>Given that we are using the <code class="md-code md-code-inline">doc_as_upsert</code> flag, a new document will be inserted if no document with the provided <code class="md-code md-code-inline">id</code> exists, and otherwise the existing <code class="md-code md-code-inline">id</code> document will be modified with the updated fields, again in a single HTTP request to the index. I could&#x2019;ve done <code class="md-code md-code-inline">doc: article</code>, but I prefer <strong>a whitelist approach</strong> where I explicitly name the fields that I want to copy over to the Elasticsearch index, which explains the <code class="md-code md-code-inline">toIndex</code> function.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> id = article._id.toString();
await <mark class="md-mark md-code-mark">client.update</mark>({
  index: <span class="md-code-string">&apos;ponyfoo&apos;</span>,
  type: <span class="md-code-string">&apos;article&apos;</span>,
  id,
  body: {
    <mark class="md-mark md-code-mark">doc</mark>: toIndex(article),
    <mark class="md-mark md-code-mark">doc_as_upsert: true</mark>
  }
});
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">toIndex</span> <span class="md-code-params">(article)</span> </span>{
  <span class="md-code-keyword">return</span> {
    created: article.created,
    title: article.title,
    slug: article.slug,
    teaser: article.teaser,
    introduction: article.introduction,
    body: article.body,
    tags: article.tags
  };
}
</code></pre> <p>Whenever an article gets updated in our MongoDB database, the changes will be mirrored onto Elasticsearch. That&#x2019;s great for new articles or changes to existing articles, but what about articles that existed before I started using Elasticsearch? Those wouldn&#x2019;t be in the index unless I changed each of them and the post-save hook picks up the changes and forwards them to Elasticsearch.</p> <h1 id="wonders-of-the-bulk-api-or-bootstrapping-an-elasticsearch-index">Wonders of the Bulk API, or Bootstrapping an Elasticsearch Index</h1> <p>To bring your Elasticsearch index up to date with your blog articles, you will want to use the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/docs-bulk.html" target="_blank" rel="noopener noreferrer" aria-label="&#x201C;The bulk API makes it possible to perform many index/delete operations in a single API call. This can greatly increase the indexing speed.&#x201D;">bulk operations API</a>, which allows you to perform several operations against the Elasticsearch index in one fell swoop. The bulk API consumes operations from an array under the <code class="md-code md-code-inline">[cmd_1, data_1?, <mark class="md-mark md-code-mark">cmd_2, data_2?</mark>, ..., cmd_n, data_n?]</code> format. The question marks note that the data component of operations is optional. Such is the case of <code class="md-code md-code-inline">delete</code> commands, which don&#x2019;t require any additional data beyond an object <code class="md-code md-code-inline">id</code>.</p> <p>Provided an array of <code class="md-code md-code-inline">articles</code> pulled from MongoDB or elsewhere, the following piece of code reduces <code class="md-code md-code-inline">articles</code> into command/data pairs on a single array, and submits all of that to Elasticsearch as a single HTTP request through its bulk API.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">await client.bulk({
  body: articles.reduce(toBulk, [])
});

<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">toBulk</span> <span class="md-code-params">(body, article)</span> </span>{
  body.push({
    <mark class="md-mark md-code-mark">update</mark>: {
      _index: <span class="md-code-string">&apos;ponyfoo&apos;</span>,
      _type: <span class="md-code-string">&apos;article&apos;</span>,
      _id: article._id.toString()
    }
  });
  body.push({
    <mark class="md-mark md-code-mark">doc</mark>: toIndex(article),
    <mark class="md-mark md-code-mark">doc_as_upsert: true</mark>
  }); <span class="md-code-comment">// <mark class="md-mark md-code-mark">toIndex</mark> from previous code block</span>
  <span class="md-code-keyword">return</span> body;
}
</code></pre> <p>If JavaScript had <a href="https://ponyfoo.com/articles/proposal-draft-for-flatten-and-flatmap" aria-label="Proposal Draft for .flatten and .flatMap on Pony Foo"><code class="md-code md-code-inline">.flatMap</code></a> we could do away with <code class="md-code md-code-inline">.reduce</code> and <code class="md-code md-code-inline">.push</code>, but we&#x2019;re not quite there yet.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">await client.bulk({
  body: articles<mark class="md-mark md-code-mark">.flatMap(</mark>article =&gt; [{
    update: {
      _index: <span class="md-code-string">&apos;ponyfoo&apos;</span>,
      _type: <span class="md-code-string">&apos;article&apos;</span>,
      _id: article._id.toString()
    }
  }, {
    doc: toIndex(article),
    doc_as_upsert: <span class="md-code-literal">true</span>
  }])
});
</code></pre> <p>Great stuff! &#x1F389;</p> <p>Up to this point we have:</p> <ul> <li>Installed Elasticsearch and the <code class="md-code md-code-inline">elasticsearch</code> npm package</li> <li>Created an Elasticsearch index for our blog</li> <li>Created an Elasticsearch mapping for articles</li> <li>Set up a hook that upserts articles when they&#x2019;re inserted or updated in our source store</li> <li>Used the bulk API to pull all articles that weren&#x2019;t synchronized into Elasticsearch yet</li> </ul> <p>We&#x2019;re still missing the awesome parts &#x2728;, though!</p> <ul> <li>Set up a <code class="md-code md-code-inline">query</code> function that takes some options and returns the articles matching the user&#x2019;s query</li> <li>Set up a <code class="md-code md-code-inline">related</code> function that takes an <code class="md-code md-code-inline">article</code> and returns similar articles</li> <li>Create an automated deployment script for Elasticsearch</li> </ul> <p><em>Shall we?</em></p> <h1 id="querying-the-elasticsearch-index">Querying the Elasticsearch Index</h1> <p>While utilizing the results of querying the Elasticsearch index is out of the scope of this article, you probably still want to know how to write a function that can query the engine you so carefully set up with your blog&#x2019;s amazing contents.</p> <p>A simple <code class="md-code md-code-inline">query(options)</code> function looks like below. It returns a <code class="md-code md-code-inline">Promise</code> and it uses <code class="md-code md-code-inline">async</code> / <code class="md-code md-code-inline">await</code>. The resulting search hits are mapped through a function that only exposes the fields we want. Again, we take a whitelisting approach as favored earlier when we inserted documents into the index. Elasticsearch offers <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/query-dsl.html" target="_blank" rel="noopener noreferrer" aria-label="&#x201C;Elasticsearch provides a full Query DSL based on JSON to define queries. Think of the Query DSL as an AST of queries&#x201D;">a querying DSL</a> you can leverage to build complex queries. For now, we&#x2019;ll only use the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/query-dsl-match-query.html" target="_blank" rel="noopener noreferrer" aria-label="&#x201C;A family of match queries that accepts text/numerics/dates, analyzes them, and constructs a query.&#x201D;"><code class="md-code md-code-inline">match</code> query</a> to find articles whose <code class="md-code md-code-inline">title</code> match the provided <code class="md-code md-code-inline">options.input</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">async <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">query</span> <span class="md-code-params">(options)</span> </span>{
  <span class="md-code-keyword">const</span> result = await client.search({
    index: <span class="md-code-string">&apos;ponyfoo&apos;</span>,
    type: <span class="md-code-string">&apos;article&apos;</span>,
    body: {
      query: {
        <mark class="md-mark md-code-mark">match</mark>: {
          <mark class="md-mark md-code-mark">title</mark>: options.input
        }
      }
    }
  });
  <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">result.hits.hits.map(searchHitToResult)</mark>;
}
</code></pre> <p>The <code class="md-code md-code-inline">searchHitToResult</code> function receives the raw search hits from the REST Elasticsearch API and maps them to simple objects that contain only the <code class="md-code md-code-inline">_id</code>, <code class="md-code md-code-inline">title</code>, and <code class="md-code md-code-inline">slug</code> fields. In addition, we&#x2019;ll include the <code class="md-code md-code-inline">_score</code> field, Elasticsearch&#x2019;s way of telling us <em>how confident we should be</em> that the search hit reliably matches the human&#x2019;s query. Typically more than enough for dealing with search results.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">searchHitToResult</span> <span class="md-code-params">(hit)</span> </span>{
  <span class="md-code-keyword">return</span> {
    _score: hit._score,
    _id: hit._id,
    title: hit._source.title,
    slug: hit._source.slug
  };
}
</code></pre> <blockquote> <p>You could always query the MongoDB database for <code class="md-code md-code-inline">_id</code> to pull in more data, such as the contents of an article.</p> </blockquote> <p>Even in the case of a simple blog, you wouldn&#x2019;t consider a search solution sufficient if users could only find articles by matching their titles. You&#x2019;d want to be able to filter by tags, and even though the article titles should be valued higher than their contents <em>(due to their prominence)</em>, you&#x2019;d still want users to be able to search articles by querying their contents directly. You probably also want to be able to specify date ranges, and then expect to see results only within the provided date range.</p> <p>What&#x2019;s more, you&#x2019;d expect to be able to fit all of this in a single querying function.</p> <h1 id="building-complex-elasticsearch-queries">Building Complex Elasticsearch Queries</h1> <p>As it turns out, we don&#x2019;t have to drastically modify our <code class="md-code md-code-inline">query</code> function to this end. Thanks to the rich querying DSL, our problem becomes finding out which types of queries we need to use, and figuring out how to stack the different parts of our query.</p> <p>To begin, we&#x2019;ll add the ability to query several fields, and not just the <code class="md-code md-code-inline">title</code>. To do that, we&#x2019;ll use the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/query-dsl-multi-match-query.html" target="_blank" rel="noopener noreferrer" aria-label="The multi_match query builds on the match query to allow multi-field queries"><code class="md-code md-code-inline">multi_match</code> query</a>, adding <code class="md-code md-code-inline">&apos;teaser&apos;, &apos;introduction&apos;, &apos;content&apos;</code> to the <code class="md-code md-code-inline">title</code> we were already querying about.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">async <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">query</span> <span class="md-code-params">(options)</span> </span>{
  <span class="md-code-keyword">const</span> result = await client.search({
    index: <span class="md-code-string">&apos;ponyfoo&apos;</span>,
    type: <span class="md-code-string">&apos;article&apos;</span>,
    body: {
      query: {
        <mark class="md-mark md-code-mark">multi_match</mark>: {
          query: options.input,
          fields: <mark class="md-mark md-code-mark">[<span class="md-code-string">&apos;title&apos;</span>, <span class="md-code-string">&apos;teaser&apos;</span>, <span class="md-code-string">&apos;introduction&apos;</span>, <span class="md-code-string">&apos;content&apos;</span>]</mark>
        }
      }
    }
  });
  <span class="md-code-keyword">return</span> result.hits.hits.map(searchHitToResult);
}
</code></pre> <p>Earlier, I brought up the fact that I want to rate the <code class="md-code md-code-inline">title</code> field higher. In the context of search, this is usually referred to as giving a term more &#x201C;weight&#x201D;. To do this through the Elasticsearch DSL, we can use the <code class="md-code md-code-inline">^</code> field modifier to boost the <code class="md-code md-code-inline">title</code> field three times.</p> <pre class="md-code-block"><code class="md-code">{
  query: {
    multi_match: {
      query: options.input,
      fields: [<mark class="md-mark md-code-mark">&apos;title^3&apos;</mark>, &apos;teaser&apos;, &apos;introduction&apos;, &apos;content&apos;]
    }
  }
}
</code></pre> <p>If we have additional filters to constrain a query, I&#x2019;ve found that the most effective way to express that is using <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/query-dsl-bool-query.html" target="_blank" rel="noopener noreferrer" aria-label="A query that matches documents matching boolean combinations of other queries.">a <code class="md-code md-code-inline">bool</code> query</a>, moving the <code class="md-code md-code-inline">filter</code> options into a function and placing our existing <code class="md-code md-code-inline">multi_match</code> query under a <code class="md-code md-code-inline">must</code> clause, within our <code class="md-code md-code-inline">bool</code> query. Bool queries are a powerful querying DSL that allow for a recursive yet declarative and simple interface to defining complex queries.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">{
  query: {
    <mark class="md-mark md-code-mark">bool</mark>: {
      <mark class="md-mark md-code-mark">filter: filters(options)</mark>,
      <mark class="md-mark md-code-mark">must</mark>: {
        multi_match: {
          query: options.input,
          fields: [<span class="md-code-string">&apos;title^3&apos;</span>, <span class="md-code-string">&apos;teaser&apos;</span>, <span class="md-code-string">&apos;introduction&apos;</span>, <span class="md-code-string">&apos;content&apos;</span>]
        }
      }
    }
  }
}
</code></pre> <p>In the simplest case, the applied <code class="md-code md-code-inline">filter</code> does nothing at all, leaving the original query unmodified. Here we return an empty <code class="md-code md-code-inline">filter</code> object.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">filters</span> <span class="md-code-params">(options)</span> </span>{
  <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">{}</mark>;
}
</code></pre> <p>When the user-provided <code class="md-code md-code-inline">options</code> object contains a <code class="md-code md-code-inline">since</code> date, we can use that to define a <code class="md-code md-code-inline">range</code> for our filter. For the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/query-dsl-range-query.html" target="_blank" rel="noopener noreferrer" aria-label="Matches documents with fields that have terms within a certain range."><code class="md-code md-code-inline">range</code> filter</a> we can specify fields and a condition. In this case we specify that the <code class="md-code md-code-inline">created</code> field must be <code class="md-code md-code-inline">gte</code> <em>(<strong>g</strong>reater <strong>t</strong>han or <strong>e</strong>qual)</em> the provided <code class="md-code md-code-inline">since</code> date. Since we moved this logic to a <code class="md-code md-code-inline">filters</code> function, we don&#x2019;t clutter the original <code class="md-code md-code-inline">query</code> function with our <em>(albeit simple)</em> filter-building algorithm. We place our filters in a <code class="md-code md-code-inline">must</code> clause within a <code class="md-code md-code-inline">bool</code> query, so that we can filter on as many concerns as we have to.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">filters</span> <span class="md-code-params">(options)</span> </span>{
  <span class="md-code-keyword">const</span> clauses = [];
  <span class="md-code-keyword">if</span> (options.since) {
    clauses.unshift(<mark class="md-mark md-code-mark">since(options.since)</mark>);
  }
  <span class="md-code-keyword">return</span> all(clauses);
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">all</span> <span class="md-code-params">(clauses)</span> </span>{
  <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">{ bool: { must: clauses } }</mark>;
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">since</span> <span class="md-code-params">(date)</span> </span>{
  <span class="md-code-keyword">return</span> <mark class="md-mark md-code-mark">{ range: { created: { gte: date } } }</mark>;
}
</code></pre> <p>When it comes to constraining a query to a set of user-provided tags, we can add <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/query-dsl-bool-query.html" target="_blank" rel="noopener noreferrer" aria-label="A query that matches documents matching boolean combinations of other queries.">a <code class="md-code md-code-inline">bool</code> filter</a> once again. Using the <code class="md-code md-code-inline">must</code> clause, we can provided an array of <code class="md-code md-code-inline">term</code> queries for the <code class="md-code md-code-inline">tags</code> field, so that articles without one of the provided tags are filtered out. That&#x2019;s because we&#x2019;re specifying that the <strong>query must match</strong> each user-provided <code class="md-code md-code-inline">tag</code> against the <code class="md-code md-code-inline">tags</code> field in the article.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">filters</span> <span class="md-code-params">(options)</span> </span>{
  <span class="md-code-keyword">const</span> tags = <span class="md-code-built_in">Array</span>.isArray(options.tags) ? options.tags : [];
  <span class="md-code-keyword">const</span> clauses = <mark class="md-mark md-code-mark">tags.map(tagToFilter)</mark>;
  <span class="md-code-keyword">if</span> (options.since) {
    clauses.unshift(<mark class="md-mark md-code-mark">since(options.since)</mark>);
  }
  <span class="md-code-keyword">return</span> all(clauses);
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">all</span> <span class="md-code-params">(clauses)</span> </span>{
  <span class="md-code-keyword">return</span> { bool: { must: clauses } };
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">since</span> <span class="md-code-params">(date)</span> </span>{
  <span class="md-code-keyword">return</span> { range: { created: { gte: date } } };
}
<span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">tagToFilter</span> <span class="md-code-params">(tag)</span> </span>{
  <span class="md-code-keyword">return</span> { term: { tags: tag } };
}
</code></pre> <p>We could keep on piling condition clauses on top of our <code class="md-code md-code-inline">query</code> function, but the bottom line is that we can easily construct a query using the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/query-dsl.html" target="_blank" rel="noopener noreferrer" aria-label="&#x201C;Elasticsearch provides a full Query DSL based on JSON to define queries. Think of the Query DSL as an AST of queries&#x201D;">Elasticsearch querying DSL</a>, and it&#x2019;s most likely going to be able to perform the query we want within a single request to the index.</p> <h1 id="finding-similar-documents">Finding Similar Documents</h1> <p>The API to find related documents is quite simple as well. Using the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.3/query-dsl-mlt-query.html" target="_blank" rel="noopener noreferrer" aria-label="&#x201C;The More Like This Query (MLT Query) finds documents that are similar to a given set of documents.&#x201D;"><code class="md-code md-code-inline">more_like_this</code> query</a>, we could specify the <code class="md-code md-code-inline">like</code> parameter to look for articles related to a user-provided document <em>&#x2013; by default, a full text search is performed</em>. We could reuse the <code class="md-code md-code-inline">filters</code> function we just built, for extra customization. You could also specify that you want at most <code class="md-code md-code-inline">6</code> articles in the response, by using the <code class="md-code md-code-inline">size</code> property.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">{
  query: {
    bool: {
      filter: filters(options),
      must: {
        <mark class="md-mark md-code-mark">more_like_this</mark>: {
          <mark class="md-mark md-code-mark">like</mark>: {
            _id: options.article._id.toString() 
          }
        }
      }
    }
  },
  <mark class="md-mark md-code-mark">size</mark>: <span class="md-code-number">6</span>
}
</code></pre> <p>Using the <code class="md-code md-code-inline">more_like_this</code> query we can quickly set up those coveted &#x201C;related articles&#x201D; that spring up on some blogging engines but feel so very hard to get working properly in your homebrew blogging enterprise.</p> <p>The best part is that Elasticsearch took care of all the details for you. I&#x2019;ve barely had to explain any search concepts at all in this blog post, and you came out with a powerful <code class="md-code md-code-inline">query</code> function that&#x2019;s easily augmented, as well as the <code class="md-code md-code-inline">body</code> of a search query for related articles <em>&#x2013; nothing too shabby!</em></p> <p>To round things out, I&#x2019;ll detail the steps I took in making sure that my deployments went smoothly with my recently added Elasticsearch toys.</p> <h1 id="rigging-for-deployment">Rigging for Deployment &#x1F680;</h1> <p>After figuring out the indexing and querying parts <em>(even though I now work at Elastic I&#x2019;m pretty far from becoming a search demigod)</em>, and setting up the existing parts of the blog so that search and related articles leverage the new Elasticsearch services I wrote for <a href="https://github.com/ponyfoo/ponyfoo/blob/c7b6f069de4c0be7ee1a899218fc677ddf4f1d7d/services/articleElasticsearch.js#L27-L43" target="_blank" rel="noopener noreferrer" aria-label="ponyfoo/ponyfoo on GitHub"><code class="md-code md-code-inline">ponyfoo/ponyfoo</code></a>, came deploying to production.</p> <p>It took a bit of research to get the deployment right for Pony Foo&#x2019;s <a href="https://www.debian.org/releases/jessie/" target="_blank" rel="noopener noreferrer" aria-label="Debian Jessie Release"><em>Debian Jessie</em></a> production environment. Interestingly, my biggest issue was figuring out how to install Java 8. The following chunk of code installs Java 8 in Debian Jessie and sets it as the default <code class="md-code md-code-inline">java</code> runtime. Note that we&#x2019;ll need the cookie in <code class="md-code md-code-inline">wget</code> so that Oracle validates the download.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;install java&quot;</span>
JAVA_PACK=jdk-<span class="md-code-number">8</span>u92-linux-x64.tar.gz
JAVA_VERSION=jdk1.<span class="md-code-number">8.0</span>_92
wget -nv --header <span class="md-code-string">&quot;Cookie: oraclelicense=accept-securebackup-cookie&quot;</span> http://download.oracle.com/otn-pub/java/jdk/<span class="md-code-number">8</span>u92-b14/<span class="md-code-variable">$JAVA_PACK</span>
sudo mkdir /opt/jdk
sudo tar -zxf <span class="md-code-variable">$JAVA_PACK</span> -C /opt/jdk
sudo update-alternatives --install /usr/bin/java java /opt/jdk/<span class="md-code-variable">$JAVA_VERSION</span>/bin/java <span class="md-code-number">100</span>
sudo update-alternatives --install /usr/bin/javac javac /opt/jdk/<span class="md-code-variable">$JAVA_VERSION</span>/bin/javac <span class="md-code-number">100</span>
</code></pre> <blockquote> <p>Before coming to this piece of code, I tried using <code class="md-code md-code-inline">apt-get</code> but nothing I did seemed to work. The <code class="md-code md-code-inline">oracle-java8-installer</code> package some suggest you should install was nowhere to be found, and the <code class="md-code md-code-inline">default-jre</code> package isn&#x2019;t all that well supported by <code class="md-code md-code-inline">elasticsearch</code>.</p> </blockquote> <p>After installing Java 8, we have to install Elasticsearch. This step involved copying and pasting Elastic&#x2019;s installation instructions, for the most part.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;install elasticsearch&quot;</span>
wget -qO - https://packages.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -
<span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;deb http://packages.elastic.co/elasticsearch/2.x/debian stable main&quot;</span> | sudo tee <span class="md-code-operator">-a</span> /etc/apt/sources.list.d/elasticsearch-<span class="md-code-number">2</span>.x.list
sudo apt-get update
sudo apt-get -y install elasticsearch
</code></pre> <p>Next up came setting up <code class="md-code md-code-inline">elasticsearch</code> as a service that also relaunches itself across reboots.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;elasticsearch as a service&quot;</span>
sudo update-rc.d elasticsearch defaults <span class="md-code-number">95</span> <span class="md-code-number">10</span>
sudo /bin/systemctl daemon-reload
sudo /bin/systemctl <span class="md-code-built_in">enable</span> elasticsearch.service
</code></pre> <blockquote> <p>I deploy <strong>Pony Foo</strong> through a series of <a href="https://ponyfoo.com/articles/immutable-deployments-packer" aria-label="Immutable Deployments and Packer on Pony Foo">immutable deployments</a>, <em>(that article had <a href="https://ponyfoo.com/articles/leveraging-immutable-deployments" aria-label="Leveraging Immutable Deployments on Pony Foo">two parts</a>! &#x1F340;)</em> building disk images along the way using Packer. For the most part, unless I&#x2019;m setting up something like Elasticsearch, the deployment consists of installing the latest <code class="md-code md-code-inline">npm</code> dependencies and updating the server to the latest version of the Node.js code base. More fundamental changes take longer, however, when I need to re-install parts of the system dependencies for example, but that doesn&#x2019;t occur as often. This leaves me with a decently automated deployment process while retaining tight control over the server infrastructure to use <code class="md-code md-code-inline">cron</code> and friends as I see fit.</p> </blockquote> <p>When I&#x2019;m ready to fire up the <code class="md-code md-code-inline">elasticsearch</code> service, I just run the following. The last command prints useful diagnostic information that comes in handy while debugging your setup.</p> <pre class="md-code-block"><code class="md-code md-lang-bash"><span class="md-code-built_in">echo</span> <span class="md-code-string">&quot;firing up elasticsearch&quot;</span>
sudo service elasticsearch restart || sudo service elasticsearch start || (sudo cat /var/<span class="md-code-built_in">log</span>/elasticsearch/error.log &amp;&amp; <span class="md-code-built_in">exit</span> <span class="md-code-number">1</span>)
sudo service elasticsearch status
</code></pre> <p>That&#x2019;s about it.</p> <blockquote> <p>If the whole deployment process feels too daunting for you, Elastic offers <a href="https://www.elastic.co/cloud" target="_blank" rel="noopener noreferrer" aria-label="Elastic Cloud Product Overview">Elastic Cloud</a>. Although, at $45/mo, it&#x2019;s mostly aimed at companies! If you&#x2019;re flying solo, you might just have to strap on your keyboards and start fiercely smashing those hot keys.</p> </blockquote> <p>There is one more step in my setup, which is that I hooked my application server up in such a way that the first search request creates the Elasticsearch index, type mapping, and bulk-inserts documents into the index. This could alternatively be done before the Node.js application starts listening for requests, but since it&#x2019;s not a crucial component of Pony Foo, that&#x2019;ll do for now!</p> <h1 id="conclusions">Conclusions</h1> <p>I had a ton of fun setting up Elasticsearch for the blog. Even though I already had a homebrew search solution, it performed very poorly and the results weren&#x2019;t anywhere close to accurate. With Elasticsearch the search results are much more on point, and hopefully will be more useful to my readers. Similarly, related articles should be more relevant now as well!</p> <p>I can&#x2019;t wait to hook Elasticsearch up with <a href="https://www.elastic.co/products/logstash" target="_blank" rel="noopener noreferrer" aria-label="Logstash Product Overview">Logstash</a> and start feeding <code class="md-code md-code-inline">nginx</code> logs into my ES instance so that I can see some realtime HTTP request data <em>&#x2013; besides what Google Analytics has been telling me &#x2013;</em> <strong>for the first time</strong> since I started blogging back in late 2012. I might do this next, when I have some free time. Afterwards, I might set up some sort of public <a href="https://www.elastic.co/products/kibana" target="_blank" rel="noopener noreferrer" aria-label="Kibana Product Overview">Kibana</a> dashboard displaying realtime metrics for Pony Foo servers. That should be fun!</p></div>
