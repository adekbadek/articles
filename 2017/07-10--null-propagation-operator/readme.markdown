<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/null-propagation-operator">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/null-propagation-operator"><div><img src="https://i.imgur.com/fmTUKsL.jpg" alt="Null Propagation Operator in JavaScript"></div></a>

<h1>Null Propagation Operator in JavaScript</h1>

<p><kbd>ecmascript</kbd> <kbd>proposal-draft</kbd></p>

<blockquote><p>There&#x2019;s a proposal in stage 1 for the <em>Null Propagation operator</em>. In this article we&#x2019;ll take a look at the proposal, which offers an alternative to null &#x2026;</p></blockquote>

<div></div>

<blockquote></blockquote>

<div></div>

<div><p>There&#x2019;s a proposal in stage 1 for the <em>Null Propagation operator</em>. In this article we&#x2019;ll take a look at the proposal, which offers an alternative to null checks ad nauseum.</p> <p>Very often, we want to grab a value deeply, such as in the following bit of code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> firstName = person.profile.name.firstName
</code></pre> <p>The <code class="md-code md-code-inline">profile</code> might not be an object. Or the <code class="md-code md-code-inline">name</code> might not be an object. So we <code class="md-code md-code-inline">null</code>-check all the things!</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> firstName = (
  person &amp;&amp;
  person.profile &amp;&amp;
  person.profile.name &amp;&amp;
  person.profile.name.firstName
)
</code></pre> <p>Or we use a library like <code class="md-code md-code-inline">lodash</code> to do the checking for us, at least there&#x2019;s less unwarranted complexity on our own bits of code.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import { get } from <span class="md-code-string">&apos;lodash&apos;</span>
<span class="md-code-keyword">const</span> firstName = get(person, [<span class="md-code-string">&apos;profile&apos;</span>, <span class="md-code-string">&apos;name&apos;</span>, <span class="md-code-string">&apos;firstName&apos;</span>])
</code></pre> <p>The Null Propagation operator is a native solution to the problem, allowing us to handle these cases by sprinkling our code with question marks. The operator is all of <code class="md-code md-code-inline">?.</code>, as we&#x2019;ll see in a bit.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> firstName = person.profile<mark class="md-mark md-code-mark">?.</mark>name<mark class="md-mark md-code-mark">?.</mark>firstName
</code></pre> <p>Note that the <code class="md-code md-code-inline">?.</code> goes right before the property access. We can think of each <code class="md-code md-code-inline">?.</code> operator as a short circuit where <em>&quot;if the expression up until this point is <code class="md-code md-code-inline">null</code> or <code class="md-code md-code-inline">undefined</code>, then the whole expression evaluates to <code class="md-code md-code-inline">undefined</code>&quot;</em>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> read = person =&gt; person.profile<mark class="md-mark md-code-mark">?.</mark>name<mark class="md-mark md-code-mark">?.</mark>firstName
read() <span class="md-code-comment">// &lt;- Error, because `person` is undefined</span>
read({}) <span class="md-code-comment">// &lt;- undefined, because of `profile?.`</span>
read({ profile: {} }) <span class="md-code-comment">// &lt;- undefined, because of `name?.`</span>
read({ profile: { name: {} } }) <span class="md-code-comment">// &lt;- undefined, because `firstName` is undefined</span>
read({ profile: { name: { firstName: <span class="md-code-string">&apos;Bob&apos;</span> } } }) <span class="md-code-comment">// &lt;- &apos;Bob&apos;</span>
</code></pre> <p>The operator can come after any expression, including function calls. In the following example we run a regular expression against a string, and if it matches we get back the matched group. Note that even though we&#x2019;re using the object property access expression notation, we have to use <code class="md-code md-code-inline">?.[expression]</code> and can&#x2019;t just use <code class="md-code md-code-inline">?[expression]</code>. This allows the compilers to disambiguate the grammar more easily.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">/(\d+)/.exec(<span class="md-code-string">&apos;abcdef&apos;</span>)<mark class="md-mark md-code-mark">?.</mark>[<span class="md-code-number">1</span>] <span class="md-code-comment">// &lt;- undefined</span>
/(\d+)/.exec(<span class="md-code-string">&apos;abc1234def&apos;</span>)<mark class="md-mark md-code-mark">?.</mark>[<span class="md-code-number">1</span>] <span class="md-code-comment">// &lt;- &apos;1234&apos;</span>
</code></pre> <p>Using Null Propagation, we could also optionally call functions. In the following example, we have the <code class="md-code md-code-inline">person</code> eat some foods, provided a <code class="md-code md-code-inline">person.eat</code> method exists. Again, the operator remains <code class="md-code md-code-inline">?.</code> to ease the burden on lexical analyzers.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">person.eat<mark class="md-mark md-code-mark">?.</mark>(carrot, pasta, apple)
</code></pre> <p>If we go back to the earlier example of reading a person&#x2019;s name, and assuming that names are in the form <code class="md-code md-code-inline">&apos;First Last&apos;</code>, we could do the following to get each part of their name, but only if they indeed have a name and only if the name property value may be split.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> read = person =&gt; person.name<mark class="md-mark md-code-mark">?.</mark>split<mark class="md-mark md-code-mark">?.</mark>(<span class="md-code-string">&apos; &apos;</span>)
read({}) <span class="md-code-comment">// &lt;- undefined, because `name` doesn&apos;t exist</span>
read({ name: <span class="md-code-number">33</span> }) <span class="md-code-comment">// &lt;- undefined, because `33` doesn&apos;t have a `split` method</span>
read({ name: <span class="md-code-string">&apos;Uncle Bob&apos;</span> }) <span class="md-code-comment">// &lt;- [&apos;Uncle&apos;, &apos;Bob&apos;]</span>
</code></pre> <p>Probably the least useful bit of the proposal is optional constructor invocation, shown in the next snippet. That said, it&#x2019;s a good idea to include this in the proposal as to avoid the drama that came with <code class="md-code md-code-inline">new</code> + <code class="md-code md-code-inline">apply</code> prior to the rest operator<sup><strong><a name="new-apply-rest-ref" href="#new-apply-rest">*</a></strong></sup>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">new</span> Carriage<mark class="md-mark md-code-mark">?.</mark>(horses)
</code></pre> <p>The proposal also discusses <em>write context</em>, that is, using the null propagation operator <code class="md-code md-code-inline">?.</code> while writing or deleting properties. These kinds of use cases rarely pop up in the wild, so the proposal probably will end up not covering them.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">person?.firstName = <span class="md-code-string">&apos;Bob&apos;</span> <span class="md-code-comment">// only carried out if `person` is not null or undefined</span>
<span class="md-code-keyword">delete</span> person?.lastName <span class="md-code-comment">// only carried out if `person` is not null or undefined</span>
</code></pre> <p>You can find the <a href="https://github.com/claudepache/es-optional-chaining" target="_blank" rel="noopener noreferrer">proposal document on GitHub</a>.</p> <p><sup><strong><a name="new-apply-rest" href="#new-apply-rest-ref">*</a></strong> The rest operator introduced a clean <code class="md-code md-code-inline">new Date(...[2017, 6, 17])</code> syntax. In the fun old days, doing <code class="md-code md-code-inline">new</code> and <code class="md-code md-code-inline">apply</code> on a constructor involved lot more fun stuff than that: <code class="md-code md-code-inline">new (Date.bind.apply(Date, [null, 2017, 6, 17]))</code>.</sup></p></div>
