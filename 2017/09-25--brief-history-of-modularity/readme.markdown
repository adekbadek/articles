<sub>&#x1F6A8; <strong>Autogenerated!</strong> See <a href="https://github.com/ponyfoo/articles/tree/noindex/contributing.markdown"><code>contributing.markdown</code></a> for details. See also: <a href="https://ponyfoo.com/articles/brief-history-of-modularity">web version</a>.</sub>

<a href="https://ponyfoo.com/articles/brief-history-of-modularity"><div><img src="https://images.ponyfoo.com/uploads/boxes-2719166-d761b325a0b84d03b8302c9d46151a43.jpg" alt="A Brief History of Modularity"></div></a>

<h1>A Brief History of Modularity</h1>

<p><kbd>ecmascript</kbd> <kbd>modules</kbd> <kbd>commonjs</kbd></p>

<blockquote><p>When it comes to JavaScript, modularity is a modern concept. In this article we&#x2019;ll quickly revisit and summarize the milestones in how modularity evolved in the &#x2026;</p></blockquote>

<div><p>When it comes to JavaScript, modularity is a modern concept. In this article we&#x2019;ll quickly revisit and summarize the milestones in how modularity evolved in the world of JavaScript. This isn&#x2019;t meant to be a comprehensive list, by any means, but instead it&#x2019;s meant to illustrate the major paradigm changes along the history of JavaScript.</p></div>

<blockquote></blockquote>

<div><h1 id="script-tags-and-closures">Script Tags and Closures</h1> <p>In the early days, JavaScript was inlined in HTML <code class="md-code md-code-inline">&lt;script&gt;</code> tags. At best, it was offloaded to dedicated script files, all of which shared a global scope.</p> <p>Any variables declared in one of these files or inline scripts would be imprinted on the global <code class="md-code md-code-inline">window</code> object, creating leaks across entirely unrelated scripts that might&#x2019;ve lead to conflicts or even broken experiences, where a variable in one script might inadvertently replace a global that another script was relying on.</p> <p>Eventually, as web applications started growing in size and complexity, the concept of scoping and the dangers of a global scope became evident and more well-known. Immediately-invoking function expressions (IIFE) were invented and became an instant mainstay. An IIFE worked by wrapping an entire file or portions of a file in a function that executed immediately after evaluation. Each function in JavaScript creates a new level of scoping, meaning <code class="md-code md-code-inline">var</code> variable bindings would be contained by the IIFE. Even though variable declarations are hoisted to the top of their containing scope, they&#x2019;d never become implicit globals, thanks to the IIFE wrapper, thus suppressing the brittleness of implicit JavaScript globals.</p> <p>Several flavors of IIFE can be found in the next example snippet. The code in each IIFE is isolated and can only escape onto the global context via explicit statements such as <code class="md-code md-code-inline">window.fromIIFE = true</code>.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">(<span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;IIFE using parenthesis&apos;</span>)
})()

~<span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;IIFE using a bitwise operator&apos;</span>)
}()

<span class="md-code-keyword">void</span> <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-built_in">console</span>.log(<span class="md-code-string">&apos;IIFE using the void operator&apos;</span>)
}()
</code></pre> <p>Using the IIFE pattern, libraries would typically create modules by exposing and then reusing a single binding on the <code class="md-code md-code-inline">window</code> object, thus avoiding global namespace pollution. The next snippet shows how we might create a <code class="md-code md-code-inline">mathlib</code> component with a <code class="md-code md-code-inline">sum</code> method in one of these IIFE-based libraries. If we wanted to add more modules to <code class="md-code md-code-inline">mathlib</code>, we could place each of them in a separate IIFE which adds its own methods to the <code class="md-code md-code-inline">mathlib</code> public interface, while anything else could stay private to the component that defined the new portion of functionality.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">void</span> <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-built_in">window</span>.mathlib = <span class="md-code-built_in">window</span>.mathlib || {}
  <span class="md-code-built_in">window</span>.mathlib.sum = sum

  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span><span class="md-code-params">(...values)</span> </span>{
    <span class="md-code-keyword">return</span> values.reduce((a, b) =&gt; a + b, <span class="md-code-number">0</span>)
  }
}()

mathlib.sum(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>)
<span class="md-code-comment">// &lt;- 6</span>
</code></pre> <p>This pattern was, coincidentally, an open invitation for JavaScript tooling to burgeon, allowing developers &#x2013; for the first time &#x2013; to safely concatenate every IIFE module into a single file, reducing the strain on the network.</p> <p>The problem in the IIFE approach was that there wasn&#x2019;t an explicitly dependency tree. This means developers had to manufacture component file lists in a precise order, so that dependencies would load before any modules that dependend on them did &#x2013; recursively.</p></div>

<div><h1 id="requirejs-angularjs-and-dependency-injection">RequireJS, AngularJS, and Dependency Injection</h1> <p>This is a problem we&#x2019;ve hardly had to think about ever since the advent of module systems like RequireJS or the dependency injection mechanism in AngularJS, both of which allowed us to explicitly name the dependencies of each module.</p> <p>The following example shows we might define the <code class="md-code md-code-inline">mathlib/sum.js</code> library using RequireJS&#x2019;s <code class="md-code md-code-inline">define</code> function, which was added to the global scope. The returned value from the <code class="md-code md-code-inline">define</code> callback is then used as the public interface for our module.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">define(<span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">()</span> </span>{
  <span class="md-code-keyword">return</span> sum

  <span class="md-code-function"><span class="md-code-keyword">function</span> <span class="md-code-title">sum</span><span class="md-code-params">(...values)</span> </span>{
    <span class="md-code-keyword">return</span> values.reduce((a, b) =&gt; a + b, <span class="md-code-number">0</span>)
  }
})
</code></pre> <p>We could then have a <code class="md-code md-code-inline">mathlib.js</code> module which aggregates all functionality we wanted to include in our library. In our case, it&#x2019;s just <code class="md-code md-code-inline">mathlib/sum</code>, but we could list as many dependencies as we wanted in the same way. We&#x2019;d list each dependency using their paths in an array, and we&#x2019;d get their public interfaces as parameters passed into our callback, in the same order.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">define([<span class="md-code-string">&apos;mathlib/sum&apos;</span>], <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(sum)</span> </span>{
  <span class="md-code-keyword">return</span> { sum }
})
</code></pre> <p>Now that we&#x2019;ve defined a library, we can consume it using <code class="md-code md-code-inline">require</code>. Notice how the dependency chain is resolved for us in the snippet below.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">require</span>([<span class="md-code-string">&apos;mathlib&apos;</span>], <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(mathlib)</span> </span>{
  mathlib.sum(<span class="md-code-number">1</span>, <span class="md-code-number">2</span>, <span class="md-code-number">3</span>)
  <span class="md-code-comment">// &lt;- 6</span>
})
</code></pre> <p>This is the upside in RequireJS and its inherent dependency tree. Regardless of whether our application contained a hundred or thousands of modules, RequireJS would resolve the dependency tree without the need for a carefully maintained list. Given we&#x2019;ve listed dependencies exactly where they were needed, we&#x2019;ve eliminated the necessity for a long list of every component and how they&#x2019;re related to one another, as well as the error-prone process of maintaining such a list. Eliminating such a large source of complexity is merely a side-effect, but not the main benefit.</p> <p>This explicitness in dependency declaration, at a module level, made it obvious how a component was related to other parts of the application. That explicitness in turn fostered a greater degree of modularity, something that was ineffective before because of how hard it was to follow dependency chains.</p> <p>RequireJS wasn&#x2019;t without problems. The entire pattern revolved around its ability to asynchronously load modules, which was ill-advised for production deployments due to how poorly it performed. Using the asynchronous loading mechanism, you issued hundreds of networks requests in a waterfall fashion before much of your code was executed. A different tool would have to be used to optimize builds for production. Then there was the verbosity factor, where you&#x2019;d end up with long lists of dependencies, a RequireJS function call, and the callback for your module. On that note, there were quite a few different RequireJS functions and several ways of invoking those functions, complicating its use. The API wasn&#x2019;t the most intuitive, because there were so many ways of doing the same thing: declaring a module with dependencies.</p> <p>The dependency injection system in AngularJS suffered from many of the same problems. It was an elegant solution at the time, relying on clever string parsing to avoid the dependency array, using function parameter names to resolve dependencies instead. This mechanism was incompatible with minifiers, which would rename parameters to single characters and thus break the injector.</p> <p>Later in the lifetime of AngularJS v1, a build task was introduced that would transform code like the following:</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">module</span>.factory(<span class="md-code-string">&apos;calculator&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(mathlib)</span> </span>{
  <span class="md-code-comment">// &#x2026;</span>
})
</code></pre> <p>Into the format in the following bit of code, which was minification-safe because it included the explicit dependency list.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-built_in">module</span>.factory(<span class="md-code-string">&apos;calculator&apos;</span>, [<span class="md-code-string">&apos;mathlib&apos;</span>, <span class="md-code-function"><span class="md-code-keyword">function</span><span class="md-code-params">(mathlib)</span> </span>{
  <span class="md-code-comment">// &#x2026;</span>
}])
</code></pre> <p>Needless to say, the delay in introducing this little-known build tool, combined with the over-engineered aspect of having an extra build step to unbreak something that shouldn&#x2019;t have been broken, discouraged the use of a pattern that carried such a negligible benefit anyway. Developers mostly chose to stick with the familiar RequireJS-like hardcoded dependency array format.</p> <h1 id="nodejs-and-the-advent-of-commonjs">Node.js and the Advent of CommonJS</h1> <p>Among the many innovations hailed by Node.js, one was the CommonJS module system &#x2013; or CJS for short. Taking advantage of the fact that Node.js programs had access to the file system, the CommonJS standard is more in line with traditional module loading mechanisms. In CommonJS, each file is a module with its own scope and context. Dependencies are loaded using a synchronous <code class="md-code md-code-inline">require</code> function that can be dynamically invoked at any time in the lifecycle of a module, as illustrated in the next snippet.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript"><span class="md-code-keyword">const</span> mathlib = <span class="md-code-built_in">require</span>(<span class="md-code-string">&apos;./mathlib&apos;</span>)
</code></pre> <p>Much like RequireJS and AngularJS, CommonJS dependencies are also referred to by a pathname. The main difference is that the boilerplate function and dependency array are now both gone, and the interface from a module could be assigned to a variable binding, or used anywhere a JavaScript expression could be used.</p> <p>Unlike RequireJS or AngularJS, CommonJS was rather strict. In RequireJS and AngularJS you could have many dynamically-defined modules per file, whereas CommonJS had a one-to-one mapping between files and modules. At the same time, RequireJS had several ways of declaring a module and AngularJS had several kinds of factories, services, providers and so on &#x2013; besides the fact that its dependency injection mechanism was tightly coupled to the AngularJS framework itself. CommonJS, in contrast, had a single way of declaring modules. Any JavaScript file was a module, calling <code class="md-code md-code-inline">require</code> would load dependencies, and anything assigned to <code class="md-code md-code-inline">module.exports</code> was its interface. This enabled better tooling and code introspection &#x2013; making it easier for tools to learn the hierarchy of a CommonJS component system.</p> <p>Eventually, Browserify was invented as way of bridging the gap between CommonJS modules for Node.js servers and the browser. Using the <code class="md-code md-code-inline">browserify</code> command-line interface program and providing it with the path to an entry point module, one could combine an unthinkable amount of modules into a single browser-ready bundle. The killer feature of CommonJS, the npm package registry, was decisive in aiding its takeover of the module loading ecosystem.</p> <p>Granted, npm wasn&#x2019;t limited to CommonJS modules or even JavaScript packages, but that was and still is by and large its primary use case. The prospect of having thousands of packages (now over half million and steadily growing) available in your web application at the press of a few fingertips, combined with the ability to reuse large portions of a system on both the Node.js web server and each client&#x2019;s web browser, was too much of a competitive advantage for the other systems to keep up.</p> <h1 id="es6-import-babel-and-webpack">ES6, <code class="md-code md-code-inline">import</code>, Babel, and Webpack</h1> <p>As ES6 became standardized in June of 2015, and with Babel transpiling ES6 into ES5 long before then, a new revolution was quickly approaching. The ES6 specification included a module system native to JavaScript, often referred to as ECMAScript Modules (ESM).</p> <p>ESM is largely influenced by CJS and its predecessors, offering a static declarative API as well as a promise-based dynamic programmative API, as illustrated next.</p> <pre class="md-code-block"><code class="md-code md-lang-javascript">import mathlib from <span class="md-code-string">&apos;./mathlib&apos;</span>
import(<span class="md-code-string">&apos;./mathlib&apos;</span>).then(mathlib =&gt; {
  <span class="md-code-comment">// &#x2026;</span>
})
</code></pre> <p>In ESM, too, every file is a module with its own scope and context. One major advantage in ESM over CJS is how ESM has &#x2013; and encourages &#x2013; a way of statically importing dependencies. Static imports vastly improve the introspection capabilities of module systems, given they can be analyzed statically and lexically extracted from the abstract syntax tree (AST) of each module in the system. Static imports in ESM are constrained to the topmost level of a module, further simplifying parsing and introspection.</p> <p>In Node.js v8.5.0, ESM module support was introduced behind a flag. Most evergreen browsers also support ESM modules behind flags.</p> <p>Webpack is a successor to Browserify that largely took over in the role of universal module bundler thanks to a broader set of features. Just like in the case of Babel and ES6, Webpack has long supported ESM with both its <code class="md-code md-code-inline">import</code> and <code class="md-code md-code-inline">export</code> statements as well as the dynamic <code class="md-code md-code-inline">import()</code> function. It has made a particularly fruitful adoption of ESM, in no little parts thanks to the introduction of a &#x201C;code-splitting&#x201D; mechanism whereby it&#x2019;s able to partition an application into different bundles to improve performance on first load experiences.</p> <p>Given how ESM is native to the language, &#x2013; as opposed to CJS &#x2013; it can be expected to completely overtake the module ecosystem in a few years time.</p></div>
